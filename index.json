[{"content":"Aixin.me\n心中有爱，遇见更好的自己\n","permalink":"https://aixin.me/about/","summary":"Aixin.me\n心中有爱，遇见更好的自己","title":"About"},{"content":"职场优秀素质： Ownership(主人翁精神) Proactive(主动积极) Passion(工作热情) Optimism(乐观自信) Result-Driven(结果导向) Thoughtful(思维缜密) Sense of Urgency(紧迫感) Negotiator(谈判专家) Inspiring(煽动力) Taste(个人品位) Yes, I Can(我能) 顶级素质 Negotiator(谈判专家) Inspiring(煽动力) Taste(个人品位) 领先素质 Result-Driven(结果导向) Thoughtful(思维缜密) Sense of Urgency(紧迫感) Yes, I Can(我能) 底层素质 Ownership(主人翁精神) Proactive(主动积极) Passion(工作热情) ","permalink":"https://aixin.me/post/opportunity-model/","summary":"职场优秀素质： Ownership(主人翁精神) Proactive(主动积极) Passion(工作热情) Optimism(乐观自信) Result-Driven(结果导向) Thoughtful(思维缜密) Sense of Urgency(紧迫感) Negotiator(谈判专家) Inspiring(煽动力) Taste(个人品位) Yes, I Can(我能) 顶级素质 Negotiator(谈判专家) Inspiring(煽动力) Taste(个人品位) 领先素质 Result-Driven(结果导向) Thoughtful(思维缜密) Sense of Urgency(紧迫感) Yes, I Can(我能) 底层素质 Ownership(主人翁精神) Proactive(主动积极) Passion(工作热情) ","title":"Opportunity素质模型"},{"content":"自我觉醒的过程其实就是心智提升的过程，心智才是拉开人与人之间距离的关键。\n第一阶段，动物本能 你对自己的言行毫无觉察，一切行为完全依托本能，对自己完全不自知。\n第二阶段，自我反思 你开始关注自己行为背后的原因了，会思考自己为什么会这么说，为什么会这么做，凡事懂得思考，处在这个阶段的人，他不会再抱怨外在的人和事，开始全方位的反思他自己。\n第三阶段，管控情绪 逐渐接纳自己，减少内耗，心态趋于平和稳定，自我与本我没有对抗。\n这个阶段的人不会由情绪控制自己，会变得非常理性，一些外界的干扰、评价、嘲笑、讽刺都不会对他产生任何的影响，他只专注做好自己。\n第四阶段，知行合一 经过长期的自我觉察和自我反思之后，行动力开始越来越强，加上时间管理和心态管理，会变得越来越自律，由大脑意识来控制行为，异常的专注，而行动时呢，会有行动来验证他的思想，执行力超强。\n第五阶段，专注忘我 进入极致专注的状态，对要达成的目标和结果进入完全的疯狂痴迷状态。\n进入这个阶段的人会迸发出超强的领袖智慧和魅力。\n第六阶段，利他之心涌现 生命力和创造力逐渐增强，内心会不断涌现出慈悲。\n进入这个阶段的人开始真正明白诸恶莫作，众善奉行，利众者众人，身边的一切资源都将会源源不断地向他靠拢。\n第七阶段，开悟觉醒 到了这个阶段的人，他会找到他自己人生的使命和目标，然后专注恒久，为之奋斗一生。\n他也真正知道了我是谁，明白了我从哪里来，想好了要到哪里去。\n人格结构理论\n本我弗洛伊德认为：人格由本我、自我、超我三部分组成。\n1、本我（Id）：位于潜意识中的本能、冲动与欲望构成本我，是人格的生物面，遵循“快乐原则”；\n2、自我（Ego）：介于本我与外部世界之间，是人格的心理面。自我的作用是一方面能使个体意识到其认识能力；另一方面使个体为了适应现实而对本我加以约束和压抑，遵循的是“现实原则”；\n3、超我（Superego）：是人格的社会面，是“道德化的自我”由“良心”和“自我理想”组成，超我的力量是指导自我、限制本我，遵循“理想原则”。\n停止精神内耗\n1、停止活在别人的眼里\n2、停止后悔\n3、停止苛求完美\n4、停止思虑过度\n5、停止陷于消极\n6、停止设限\n7、停止反复犹豫\n8、停止自我攻击\n9、停止拖延\n马斯洛需求层次理论\n马斯洛把需求分成生理需求、安全需求、社交需求、尊重需求、和自我实现需求五类，依次由较低层次到较高层次排列。各层次需要的基本含义如下：\n生理上的需要： 这是人类维持自身生存的最基本要求。如果这些需要（除性以外）任何一项得不到满足，人类个人的生理机能就无法正常运转。换而言之，人类的生命就会因此受到威胁。在这个意义上说，生理需要是推动人们行动最首要的动力。马斯洛认为，只有这些最基本的需要满足到维持生存所必需的程度后，其他的需要才能成为新的激励因素，而到了此时，这些已相对满足的需要也就不再成为激励因素了。\n安全上的需要： 马斯洛认为，整个有机体是一个追求安全的机制，人的感受器官、效应器官、智能和其他能量主要是寻求安全的工具，甚至可以把科学和人生观都看成是满足安全需要的一部分。当然，当这种需要一旦相对满足后，也就不再成为激励因素了。\n情感和归属的需要： 人人都希望得到相互的关系和照顾。感情上的需要比生理上的需要来的细致，它和一个人的生理特性、经历、教育、宗教信仰都有关系。\n尊重的需要： 人人都希望自己有稳定的社会地位，要求个人的能力和成就得到社会的承认。尊重的需要又可分为内部尊重和外部尊重。内部尊重是指一个人希望在各种不同情境中有实力、能胜任、充满信心、能独立自主。总之，内部尊重就是人的自尊。外部尊重是指一个人希望有地位、有威信，受到别人的尊重、信赖和高度评价。马斯洛认为，尊重需要得到满足，能使人对自己充满信心，对社会满腔热情，体验到自己活着的用处和价值。\n自我实现的需要： 这是最高层次的需要，它是指实现个人理想、抱负，发挥个人的能力到最大程度，达到自我实现境界的人，接受自己也接受他人，解决问题能力增强，自觉性提高，善于独立处事，要求不受打扰地独处，完成与自己的能力相称的一切事情的需要。也就是说，人必须干称职的工作，这样才会使他们感到最大的快乐。马斯洛提出，为满足自我实现需要所采取的途径是因人而异的。\n来源《自我与人格结构》\n人格心理学\n人格是个体在行为上的内部倾向，它表现为个体适应环境时在能力、情绪、需要、动机、兴趣、态度、价值观、气质、性格和体质等方面的整合，是具有动力一致性和连续性的自我，使个体在社会化过程中形成的给人以特色的心身组织。\n五种普遍的人格特征，包括外向性（extraversion）、神经质性（neuroticism）、和善性（agreeableness）、严谨自律性（conscientiousness），和开放性（openness to experience）。\n人格大五模型 外向性 神经质 和善性 严谨自律性 开放性 和人格大五模型有关的特定特征 爱交朋友、亲切 焦虑、感情脆弱 信任、温厚的 自律、有组织的 丰富想象力、创意 人格的八种人格划分：\n外向思考型： 这类型的人，偏爱知性生活，尽量让自己的生活活动，合乎知性结论。所谓知性结论，就是客观而普遍为一般接受。不独断、不任性、谨守客观。以知性为行动规范，客观的分清各种事实和条件，仔细考虑之后才下结论。对人待己，采用相同基准。与人相处，分别善恶、共分美丑等等，都是这个基准为优先。\n外向感情型： 这类型的人多半是女性，这种类型的女性，生活方式顺应感情，感情也能配合周围的状况，价值观也是一样。\n外向感觉型： 这类型的人对客观的事实非常敏锐，注重的是具体的事实。当他凭感觉具体的享受某种事物时，必定体会出生命的喜悦。如果他举止高尚，你定是个有着高尚兴趣的唯美主义者。把自己的感觉提高到美的纯粹最高境界，享受旁人无法体会的艺术天地。\n外向直觉型： 这类型的人，具有洞察客观事实背后这可能性的能力。这种人注重的不是现实，而是可能性，并且不断的追求可能性。安定的生活环境对他而言有如地狱，令人窒息。当他开始追逐可能性时，非常的热衷，有的人甚至显现得异常狂热。但是一旦遇到瓶颈无法突破时，立刻冷淡下来，干脆放弃。\n内向思考型： 这类型的人和刚才的“外向思考型”一样，追随理念，只不过方向是朝内，而不是朝外。在自己的内部建立成一个理念世界，积极的推动发展，不会因为怕麻烦、危险、被视为异端、伤害与他人之间的感情等种理由而放弃。\n内向感情型： 内向感情型的人，以女性居多。这类型的人的感情，受到内在、主观的要素所支配。感情的深度，外人完全看不出来。沉默、孤僻、厌恶粗俗的人。外人看来文静有礼，捉摸不定。多愁善感，有时会被别人认为“这种人，对别人的幸或是不幸，完全无动于衷”。\n内向感觉型： 与所有内向型的人一样，内向感觉型的人也是远离外部的客观世界，沉浸在自己的主观感觉之中。它们往往不看重事物本身，却关注着事物的效果和自身深刻的主观感觉。艺术家往往倾向于这种类型。\n内向直觉型： 这类型的人，可能成为预言家或艺术家。因为他们内在的直觉，在受到了外界的刺激开始活动时，只注意自己的内在感觉，不会被外界所眩感。\n","permalink":"https://aixin.me/post/self-awakening/","summary":"自我觉醒的过程其实就是心智提升的过程，心智才是拉开人与人之间距离的关键。\n第一阶段，动物本能 你对自己的言行毫无觉察，一切行为完全依托本能，对自己完全不自知。\n第二阶段，自我反思 你开始关注自己行为背后的原因了，会思考自己为什么会这么说，为什么会这么做，凡事懂得思考，处在这个阶段的人，他不会再抱怨外在的人和事，开始全方位的反思他自己。\n第三阶段，管控情绪 逐渐接纳自己，减少内耗，心态趋于平和稳定，自我与本我没有对抗。\n这个阶段的人不会由情绪控制自己，会变得非常理性，一些外界的干扰、评价、嘲笑、讽刺都不会对他产生任何的影响，他只专注做好自己。\n第四阶段，知行合一 经过长期的自我觉察和自我反思之后，行动力开始越来越强，加上时间管理和心态管理，会变得越来越自律，由大脑意识来控制行为，异常的专注，而行动时呢，会有行动来验证他的思想，执行力超强。\n第五阶段，专注忘我 进入极致专注的状态，对要达成的目标和结果进入完全的疯狂痴迷状态。\n进入这个阶段的人会迸发出超强的领袖智慧和魅力。\n第六阶段，利他之心涌现 生命力和创造力逐渐增强，内心会不断涌现出慈悲。\n进入这个阶段的人开始真正明白诸恶莫作，众善奉行，利众者众人，身边的一切资源都将会源源不断地向他靠拢。\n第七阶段，开悟觉醒 到了这个阶段的人，他会找到他自己人生的使命和目标，然后专注恒久，为之奋斗一生。\n他也真正知道了我是谁，明白了我从哪里来，想好了要到哪里去。\n人格结构理论\n本我弗洛伊德认为：人格由本我、自我、超我三部分组成。\n1、本我（Id）：位于潜意识中的本能、冲动与欲望构成本我，是人格的生物面，遵循“快乐原则”；\n2、自我（Ego）：介于本我与外部世界之间，是人格的心理面。自我的作用是一方面能使个体意识到其认识能力；另一方面使个体为了适应现实而对本我加以约束和压抑，遵循的是“现实原则”；\n3、超我（Superego）：是人格的社会面，是“道德化的自我”由“良心”和“自我理想”组成，超我的力量是指导自我、限制本我，遵循“理想原则”。\n停止精神内耗\n1、停止活在别人的眼里\n2、停止后悔\n3、停止苛求完美\n4、停止思虑过度\n5、停止陷于消极\n6、停止设限\n7、停止反复犹豫\n8、停止自我攻击\n9、停止拖延\n马斯洛需求层次理论\n马斯洛把需求分成生理需求、安全需求、社交需求、尊重需求、和自我实现需求五类，依次由较低层次到较高层次排列。各层次需要的基本含义如下：\n生理上的需要： 这是人类维持自身生存的最基本要求。如果这些需要（除性以外）任何一项得不到满足，人类个人的生理机能就无法正常运转。换而言之，人类的生命就会因此受到威胁。在这个意义上说，生理需要是推动人们行动最首要的动力。马斯洛认为，只有这些最基本的需要满足到维持生存所必需的程度后，其他的需要才能成为新的激励因素，而到了此时，这些已相对满足的需要也就不再成为激励因素了。\n安全上的需要： 马斯洛认为，整个有机体是一个追求安全的机制，人的感受器官、效应器官、智能和其他能量主要是寻求安全的工具，甚至可以把科学和人生观都看成是满足安全需要的一部分。当然，当这种需要一旦相对满足后，也就不再成为激励因素了。\n情感和归属的需要： 人人都希望得到相互的关系和照顾。感情上的需要比生理上的需要来的细致，它和一个人的生理特性、经历、教育、宗教信仰都有关系。\n尊重的需要： 人人都希望自己有稳定的社会地位，要求个人的能力和成就得到社会的承认。尊重的需要又可分为内部尊重和外部尊重。内部尊重是指一个人希望在各种不同情境中有实力、能胜任、充满信心、能独立自主。总之，内部尊重就是人的自尊。外部尊重是指一个人希望有地位、有威信，受到别人的尊重、信赖和高度评价。马斯洛认为，尊重需要得到满足，能使人对自己充满信心，对社会满腔热情，体验到自己活着的用处和价值。\n自我实现的需要： 这是最高层次的需要，它是指实现个人理想、抱负，发挥个人的能力到最大程度，达到自我实现境界的人，接受自己也接受他人，解决问题能力增强，自觉性提高，善于独立处事，要求不受打扰地独处，完成与自己的能力相称的一切事情的需要。也就是说，人必须干称职的工作，这样才会使他们感到最大的快乐。马斯洛提出，为满足自我实现需要所采取的途径是因人而异的。\n来源《自我与人格结构》\n人格心理学\n人格是个体在行为上的内部倾向，它表现为个体适应环境时在能力、情绪、需要、动机、兴趣、态度、价值观、气质、性格和体质等方面的整合，是具有动力一致性和连续性的自我，使个体在社会化过程中形成的给人以特色的心身组织。\n五种普遍的人格特征，包括外向性（extraversion）、神经质性（neuroticism）、和善性（agreeableness）、严谨自律性（conscientiousness），和开放性（openness to experience）。\n人格大五模型 外向性 神经质 和善性 严谨自律性 开放性 和人格大五模型有关的特定特征 爱交朋友、亲切 焦虑、感情脆弱 信任、温厚的 自律、有组织的 丰富想象力、创意 人格的八种人格划分：\n外向思考型： 这类型的人，偏爱知性生活，尽量让自己的生活活动，合乎知性结论。所谓知性结论，就是客观而普遍为一般接受。不独断、不任性、谨守客观。以知性为行动规范，客观的分清各种事实和条件，仔细考虑之后才下结论。对人待己，采用相同基准。与人相处，分别善恶、共分美丑等等，都是这个基准为优先。\n外向感情型： 这类型的人多半是女性，这种类型的女性，生活方式顺应感情，感情也能配合周围的状况，价值观也是一样。\n外向感觉型： 这类型的人对客观的事实非常敏锐，注重的是具体的事实。当他凭感觉具体的享受某种事物时，必定体会出生命的喜悦。如果他举止高尚，你定是个有着高尚兴趣的唯美主义者。把自己的感觉提高到美的纯粹最高境界，享受旁人无法体会的艺术天地。","title":"自我觉醒"},{"content":"// 是否为空 vernull = function(value){ if(value.trim(value).length == 0){ return false; }else{ return true; } } // 身份证校验 veridc = function(value){ var ext = /(^\\d{15}\u0026amp;)|(^\\d{18})|(^\\d{17}(\\d|X|x)$)/; return ext.test(value); } // 英文校验 veren = function(value){ var ext = /(^[a-zA-Z]+$)/; return ext.test(value); } // 数字校验 vernum = function(value){ var ext = /^[0-9]*$/; return ext.test(value); } // 小数校验 verdou = function(value){ var ext = /^[0-9]+(.[0-9]{1,3})?$/; return ext.test(value); } // 邮箱校验 vermail = function(value){ var ext = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\\.[a-zA-Z0-9_-]{2,3}){1,2})$/; return ext.test(value); } // 手机号校验 vermob =function(value){ var ext = /^1[3456789][0-9]{9}$/; return ext.test(value); } ","permalink":"https://aixin.me/post/javascript-validation-method/","summary":"// 是否为空 vernull = function(value){ if(value.trim(value).length == 0){ return false; }else{ return true; } } // 身份证校验 veridc = function(value){ var ext = /(^\\d{15}\u0026amp;)|(^\\d{18})|(^\\d{17}(\\d|X|x)$)/; return ext.test(value); } // 英文校验 veren = function(value){ var ext = /(^[a-zA-Z]+$)/; return ext.test(value); } // 数字校验 vernum = function(value){ var ext = /^[0-9]*$/; return ext.test(value); } // 小数校验 verdou = function(value){ var ext = /^[0-9]+(.[0-9]{1,3})?$/; return ext.test(value); } // 邮箱校验 vermail = function(value){ var ext = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((\\.","title":"JavaScript validation method"},{"content":"基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\nBoolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\nlet isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\nlet decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（\u0026quot;）或单引号（'）表示字符串。\nlet name: string = \u0026#34;bob\u0026#34;; name = \u0026#34;smith\u0026#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式\nlet name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I\u0026#39;ll be ${ age + 1 } years old next month.`; 这与下面定义sentence的方式效果相同：\nlet sentence: string = \u0026#34;Hello, my name is \u0026#34; + name + \u0026#34;.\\n\\n\u0026#34; + \u0026#34;I\u0026#39;ll be \u0026#34; + (age + 1) + \u0026#34; years old next month.\u0026#34;; Array TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：\nlet list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array\u0026lt;元素类型\u0026gt;：\nlet list: Array\u0026lt;number\u0026gt; = [1, 2, 3]; Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元组。\n// Declare a tuple type let x: [string, number]; // Initialize it x = [\u0026#39;hello\u0026#39;, 10]; // OK // Initialize it incorrectly x = [10, \u0026#39;hello\u0026#39;]; // Error 当访问一个已知索引的元素，会得到正确的类型：\nconsole.log(x[0].substr(1)); // OK console.log(x[1].substr(1)); // Error, \u0026#39;number\u0026#39; does not have \u0026#39;substr\u0026#39; 当访问一个越界的元素会报错。\nx[3] = \u0026#34;world\u0026#34;; // Error, Property \u0026#39;3\u0026#39; does not exist on type \u0026#39;[string, number]\u0026#39;. console.log(x[5].toString()); // Error, Property \u0026#39;5\u0026#39; does not exist on type \u0026#39;[string, number]\u0026#39;. Enum enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color {Red, Green, Blue} let c: Color = Color.Green; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从1开始编号：\nenum Color {Red = 1, Green, Blue} let c: Color = Color.Green; 或者，全部都采用手动赋值：\nenum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\nenum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; console.log(colorName); // 显示\u0026#39;Green\u0026#39;因为上面代码里它的值是2 Unknown 当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 unknown 类型。\nlet notSure: unknown = 4; notSure = \u0026#34;maybe a string instead\u0026#34;; // OK, definitely a boolean notSure = false; 如果你有一个 unknwon 类型的变量，你可以通过进行 typeof 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：\n// @errors: 2322 2322 2322 declare const maybe: unknown; // \u0026#39;maybe\u0026#39; could be a string, object, boolean, undefined, or other types const aNumber: number = maybe; if (maybe === true) { // TypeScript knows that maybe is a boolean now const aBoolean: boolean = maybe; // So, it cannot be a string const aString: string = maybe; } if (typeof maybe === \u0026#34;string\u0026#34;) { // TypeScript knows that maybe is a string const aString: string = maybe; // So, it cannot be a boolean const aBoolean: boolean = maybe; } Any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量：\nlet notSure: any = 4; notSure = \u0026#34;maybe a string instead\u0026#34;; notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\nlet notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn\u0026#39;t check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property \u0026#39;toFixed\u0026#39; doesn\u0026#39;t exist on type \u0026#39;Object\u0026#39;. 注意：应避免使用Object，而是使用非原始object类型。\n当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\nlet list: any[] = [1, true, \u0026#34;free\u0026#34;]; list[1] = 100; Void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void：\nfunction warnUser(): void { console.log(\u0026#34;This is my warning message\u0026#34;); } 声明一个void类型的变量没有什么大用，因为你只能为它赋予null（只在--strictNullChecks未指定时）和undefined：\nlet unusable: void = undefined; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似，它们的本身的类型用处不是很大：\n// Not much else we can assign to these variables! let u: undefined = undefined; let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。\n然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给any和它们各自的类型（有一个例外是undefined还可以赋值给void类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。\n联合类型是高级主题，我们会在以后的章节里讨论它。\n注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。\nNever never类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。\n下面是一些返回never类型的函数：\n// 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\u0026#34;Something failed\u0026#34;); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object object表示非原始类型，也就是除number，string，boolean，bigint，symbol，null或undefined之外的类型。\n使用object类型，就可以更好的表示像Object.create这样的API。例如：\ndeclare function create(o: object | null): void; create({ prop: 0 }); // OK create(null); // OK create(42); // Error create(\u0026#34;string\u0026#34;); // Error create(false); // Error create(undefined); // Error 类型断言 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n类型断言有两种形式。 其一是“尖括号”语法：\nlet someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; 另一个为as语法：\nlet someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。\n关于let 你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let是ES2015引入的关键字，它比var更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用let来解决，所以尽可能地使用let来代替var吧。\n关于 Number, String, Boolean, Symbol 和 Object 我们很容易会认为 Number、 String、 Boolean、Symbol 以及 Object 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：\n// @errors: 2339 function reverse(s: String): String { return s.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); } reverse(\u0026#34;hello world\u0026#34;); 相对地，我们应该使用 number、string、boolean、object 和 symbol\nfunction reverse(s: string): string { return s.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); } reverse(\u0026#34;hello world\u0026#34;); ","permalink":"https://aixin.me/post/typescript-basic-types/","summary":"基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\nBoolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\nlet isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\nlet decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（\u0026quot;）或单引号（'）表示字符串。\nlet name: string = \u0026#34;bob\u0026#34;; name = \u0026#34;smith\u0026#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式\nlet name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }.","title":"Typescript Basic Types"},{"content":"官网：https://eggjs.org/zh-cn/\n安装 // 1、创建并进入项目目录\rmkdir egg-example \u0026amp;\u0026amp; cd egg-example\r// 2、初始化\rnpm init egg --type=simple\r// 3、安装项目\rnpm i\r// 4、启动项目\rnpm run dev\r// http://localhost:7001 type的类型\nsimple - 基础应用模板\nmicroservice - 基于egg的微服务模板\nsequelize - 带有sequelize的egg应用\nts - typescript的基础应用模板\nempty - 空模板\nplugin - egg 插件模板\nframework - 框架模板\n核心功能 1、控制器 Controller // app/controller/home.js\rconst Controller = require(\u0026#39;egg\u0026#39;).Controller;\rclass HomeController extends Controller {\rasync index() {\rthis.ctx.body = \u0026#39;Hello world\u0026#39;;\r}\r}\rmodule.exports = HomeController; 2、路由 Router // app/router.js\rmodule.exports = app =\u0026gt; {\rconst { router, controller } = app;\rrouter.get(\u0026#39;/\u0026#39;, controller.home.index);\r}; 3、服务 service // app/service/news.js\rconst Service = require(\u0026#39;egg\u0026#39;).Service;\rclass NewsService extends Service {\rasync list(page = 1) {\r// read config\rconst { serverUrl, pageSize } = this.config.news;\r// use build-in http client to GET hacker-news api\rconst { data: idList } = await this.ctx.curl(`${serverUrl}/topstories.json`, {\rdata: {\rorderBy: \u0026#39;\u0026#34;$key\u0026#34;\u0026#39;,\rstartAt: `\u0026#34;${pageSize * (page - 1)}\u0026#34;`,\rendAt: `\u0026#34;${pageSize * page - 1}\u0026#34;`,\r},\rdataType: \u0026#39;json\u0026#39;,\r});\r// parallel GET detail\rconst newsList = await Promise.all(\rObject.keys(idList).map(key =\u0026gt; {\rconst url = `${serverUrl}/item/${idList[key]}.json`;\rreturn this.ctx.curl(url, { dataType: \u0026#39;json\u0026#39; });\r})\r);\rreturn newsList.map(res =\u0026gt; res.data);\r}\r}\rmodule.exports = NewsService; 4、模板渲染 view 需要单独安装视图插件，比如egg-view-nunjucks等\n5、配置文件 // config/config.default.js\rexports.keys = \u0026lt;此处改为你自己的 Cookie 安全字符串\u0026gt;; 6、静态资源 app/public\r├── css\r│ └── news.css\r└── js\r├── lib.js\r└── news.js 7、 编写扩展 // app/extend/helper.js\rconst moment = require(\u0026#39;moment\u0026#39;);\rexports.relativeTime = time =\u0026gt; moment(new Date(time * 1000)).fromNow(); 8、编写 Middleware // app/middleware/robot.js\r// options === app.config.robot\rmodule.exports = (options, app) =\u0026gt; {\rreturn async function robotMiddleware(ctx, next) {\rconst source = ctx.get(\u0026#39;user-agent\u0026#39;) || \u0026#39;\u0026#39;;\rconst match = options.ua.some(ua =\u0026gt; ua.test(source));\rif (match) {\rctx.status = 403;\rctx.message = \u0026#39;Go away, robot.\u0026#39;;\r} else {\rawait next();\r}\r}\r};\r// config/config.default.js\r// add middleware robot\rexports.middleware = [\r\u0026#39;robot\u0026#39;\r];\r// robot\u0026#39;s configurations\rexports.robot = {\rua: [\r/Baiduspider/i,\r]\r}; 9、单元测试 // test/app/middleware/robot.test.js\rconst { app, mock, assert } = require(\u0026#39;egg-mock/bootstrap\u0026#39;);\rdescribe(\u0026#39;test/app/middleware/robot.test.js\u0026#39;, () =\u0026gt; {\rit(\u0026#39;should block robot\u0026#39;, () =\u0026gt; {\rreturn app.httpRequest()\r.get(\u0026#39;/\u0026#39;)\r.set(\u0026#39;User-Agent\u0026#39;, \u0026#34;Baiduspider\u0026#34;)\r.expect(403);\r});\r}); ","permalink":"https://aixin.me/post/eggjs-basic-tutorial/","summary":"官网：https://eggjs.org/zh-cn/\n安装 // 1、创建并进入项目目录\rmkdir egg-example \u0026amp;\u0026amp; cd egg-example\r// 2、初始化\rnpm init egg --type=simple\r// 3、安装项目\rnpm i\r// 4、启动项目\rnpm run dev\r// http://localhost:7001 type的类型\nsimple - 基础应用模板\nmicroservice - 基于egg的微服务模板\nsequelize - 带有sequelize的egg应用\nts - typescript的基础应用模板\nempty - 空模板\nplugin - egg 插件模板\nframework - 框架模板\n核心功能 1、控制器 Controller // app/controller/home.js\rconst Controller = require(\u0026#39;egg\u0026#39;).Controller;\rclass HomeController extends Controller {\rasync index() {\rthis.ctx.body = \u0026#39;Hello world\u0026#39;;\r}\r}\rmodule.","title":"Egg.js Basic Tutorial"},{"content":"在axure交互设计时，函数可以用在条件公式和需要赋值的地方，其基本语法是用双方括号包含，变量值和函数用英文句号连接。\n例如：[[LVAR. Width]] 表示变量LVAR的宽度，[[This. Width]] 当前元件的宽度\n一、元件函数 名称 用途 This 获取当前元件对象。当前元件是指当前添加交互动作的元件 Target 获取目标元件对象。目标元件是指当前交互动作控制的元件。 x 获取元件对象的X轴坐标值。 y 获取元件对象的Y轴坐标值。 width 获取元件对象的宽度值 scrollX 获取元件对象的水平滚动距离（当前仅限动态面板） scrollY 获取元件对象的垂直滚动距离（当前仅限动态面板） text 获取元件对象的文本文字 name 获取元件对象的自定义名称。 top 获取元件对象的上边界坐标值。 left 获取元件对象的左边界坐标值。 right 获取元件对象的右边界坐标值。 bottom 获取元件对象的下边界坐标值。 opacity 获取元件对象的不透明比例。 rotation 获取元件对象的旋转角度。 二、鼠标指针函数 名称 用途 Cursor.x 鼠标指针在页面中位置的X轴坐标。 Cursor.y 鼠标指针在页面中位置的Y轴坐标。 DragX 鼠标指针沿X轴拖动元件时的瞬间(0.01秒)拖动距离。 DragY 鼠标指针沿Y轴拖动元件时的瞬间(0.01秒)拖动距离。 TotalDragX 鼠标指针拖动元件从开始到结束的X轴移动距离。 TotalDragY 鼠标指针拖动元件从开始到结束的Y轴移动距离。 DragTime 鼠标指针拖动元件从开始到结束的总时长。 三、窗口函数 名称 用途 Window.width 打开原型页面的浏览器当前宽度。 Window.height 打开原型页面的浏览器当前高度。 Window.scrollX 浏览器中页面水平滚动的距离。 Window.scrollY 浏览器中页面垂直滚动的距离。 四、页面函数 名称 用途 PageName 获取当前页面的名称。 五、数字函数 名称 用途 toExponential(decimalPoints) 用途：值转换为指数计数法。参数：decimalPoints为保留小数的位数。 toFixed(decimalPoints) 用途：将一个数字转为保留指定位数的小数，小数位数超出指定位数时进行四舍五入。参数：decimalPoints为保留小数的位数。 toPrecision(length) 用途：把数字格式化为指定的长度。参数：length为格式化后的数字长度，小数点不计入长度。 六、数学函数 名称 用途 Math.abs(x) 计算参数数值的绝对值。 参数：x为数值。 Math.acos(x) 获取一个数值的反余弦弧度值，其范围是 0~ pi 。 参数：x为数值，范围在 -1~1 之间。 Math.asin(x) 获取一个数值的反正弦值。 参数：x为数值，范围在 -1~1 之间。 Math.atan(x) 获取一个数值的反正切值。 参数：x为数值。 Math.atan2(y,x) 获取某一点(x,y)的角度值。 参数：“x,y”为点的坐标数值。 Math.ceil(x) 向上取整函数，获取大于或者等于指定数值的最小整数。 参数：x为数值 Math.cos(x) 余弦函数。 参数：x为弧度数值。 Math.exp(x) 指数函数，计算以e为底的指数。 参数：x为数值。 Math.floor(x) 向下取整函数，获取小于或者等于指定数值的最大整数。 参数：x为数值。 Math.log(x) 对数函数，计算以e为底的对数值。 参数：x为数值。 Math.max(x,y) 获取参数中的最大值。 参数：“x,y”表示多个数值，而非2个数值。 Math.min(x,y) 获取参数中的最小值。 参数：“x,y”表示多个数值，而非2个数值。 Math.pow(x,y) 幂函数，计算x的y次幂。 参数：x不能为负数且y为小数，或者x为0且y小于等于0。 Math.random() 随机数函数，返回一个0~1之间的随机数。 示例：获取10-15之间的随机小数，计算公式为Math.random()*5+10。 Math.sin(x) 正弦函数。 参数：x为弧度数值。 Math.sqrt(x) 平方根函数。 参数：x为数值。 Math.tan(x) 正切函数。 参数：x为弧度数值。 七、时间函数 名称 用途 Now 获取当前计算机系统日期对象。 GenDate 获取原型生成日期对象。 getDate() 获取日期对象“日期”部分数值(1 ~ 31)。 getDay() 获取日期对象“星期”部分的数值(0 ~ 6)。 getDayOfWeek() 获取日期对象“星期”部分的英文名称。 getFullYear() 获取日期对象“年份”部分四位数值。 getHours() 获取日期对象“小时”部分数值(0 ~ 23)。 getMilliseconds() 获取日期对象的毫秒数(0 ~ 999)。 getMinutes() 获取日期对象“分钟”部分数值(0 ~59)。 getMonth() 获取日期对象“月份”部分的数值(1 ~ 12)。 getMonthName() 获取日期对象“月份”部分的英文名称。 getSeconds() 获取日期对象“秒数”部分数值(0 ~59)。 getTime() 获取当前日期对象中的时间值。该时间值表示从1970年1月1日00:00:00开始，到当前日期对象时，所经过的毫秒数，以格林威治时间为准。 getTimezoneOffset() 获取世界标准时间(UTC)与当前主机时间之间的分钟差值。 getUTCDate() 使用世界标准时间获取当前日期对象“日期”部分数值(1 ~ 31)。 getUTCDay() 使用世界标准时间获取当前日期对象“星期”部分的数值(0 ~ 6)。 getUTCFullYear() 使用世界标准时间获取当前日期对象“年份”部分四位数值。 getUTCHours() 使用世界标准时间获取当前日期对象“小时”部分数值(0 ~ 23) getUTCMilliseconds() 使用世界标准时间获取当前日期对象的毫秒数(0 ~ 999)。 getUTCMinutes() 使用世界标准时间获取当前日期对象“分钟”部分数值(0 ~59)。 getUTCMonth() 使用世界标准时间获取当前日期对象“月份”部分的数值(1 ~ 12)。 getUTCSeconds() 使用世界标准时间获取当前日期对象“秒数”部分数值(0 ~59)。 Date.parse(datestring) 用于分析一个包含日期的字符串，并返回该日期与1970年1月1日00:00:00之间相差的毫秒数 参数：datestring为日期格式的字符串，格式为：yyyy/mm/dd hh:mm:ss。 toDateString() 以字符串的形式获取一个日期。 toISOString() 获取当前日期对象的IOS格式的日期字串，格式：YYYY-MM-DDTHH:mm:ss.sssZ。 toJSON() 获取当前日期对象的JSON格式的日期字串，格式： YYYY-MM-DDTHH:mm:ss.sssZ。 toLocaleDateString() 以字符串的形式获取本地化当前日期对象。并且只包含“年月日”部分的短日期信息。 toLocaleTimeString() 以字符串的形式获取本地化当前日期对象。并且只包含“时分秒”部分的短日期信息。 toUTCString() 以字符串的形式获取相对于当前日期对象的世界标准时间。 Date.UTC(year,month,day,hour,min,sec,millisec) 获取相对于1970 年 1 月 1 日 00:00:00的世界标准时间，与指定日期对象之间相差的毫秒数。 参数：组成指定日期对象的年、月、日、时、分、秒以及毫秒的数值。 valueOf() 获取当前日期对象的原始值。 addYears(years) 将指定的年份数加到当前日期对象上，获取一个新的日期对象。 参数：years为整数数值，正负均可。 addMonths(months) 将指定的月份数加到当前日期对象上，获取一个新的日期对象。 参数：months为整数数值，正负均可。 addDays(days) 将指定的天数加到当前日期对象上，获取一个新的日期对象。 参数：days为整数数值，正负均可。 addHours(hours) 将指定的小时数加到当前日期对象上，获取一个新的日期对象。 参数：hours为整数数值，正负均可。 addMinutes(minutes) 将指定的分钟数加到当前日期对象上，获取一个新的日期对象。 参数：minutes为整数数值，正负均可。 addSeconds(seconds) 将指定的秒数加到当前日期对象上，获取一个新的日期对象。 参数：seconds为整数数值，正负均可。 addMilliseconds(ms) 将指定的毫秒数加到当前日期对象上，获取一个新的日期对象。 参数：ms为整数数值，正负均可。 Year 获取系统日期对象“年份”部分的四位数值。 Month 获取系统日期对象“月份”部分数值(1 ~ 12)。 Day 获取系统日期对象“日期”部分数值(1 ~ 31)。 Hours 获取系统日期对象“小时”部分数值(0 ~ 23)。 Minutes 获取系统日期对象“分钟”部分数值(0 ~ 59)。 Seconds 获取系统日期对象“秒数”部分数值(0 ~ 59)。 八、字符串函数 名称 用途 length 获取当前文本对象的长度，即字符个数；1个汉字的长度按1计算。 charAt(index) 获取当前文本对象中指定位置的字符； 参数：index为大于等于0的整数。 charCodeAt(index) 获取当前文本对象中指定位置字符的Unicode编码（中文编码段19968 ~ 40622）；字符起始位置从0开始。 参数：index为大于等于0的整数。 concat(‘string’) 将当前文本对象与另一个字符串组合。 参数：string为组合在后方的字符串。 indexOf(‘searchValue’,start) 从左至右获取查询字符串在当前文本对象中首次出现的位置。未查询到时返回值为-1。 参数：searchValue为查询的字符串；start为查询的起始位置。该参数可省略，官方未给出此参数，经测试可用。 lastIndexOf(‘searchvalue’,start) 从右至左获取查询字符串在当前文本对象中首次出现的位置。未查询到时返回值为-1。 参数：searchValue为查询的字符串；start为查询的起始位置。该参数可省略，官方未给出此参数，经测试可用。 replace(‘searchvalue’,’newvalue’) 用新的字符串替换当前文本对象中指定的字符串。 参数：searchvalue为被替换的字符串；newvalue为新文本对象或字符串。 slice(start,end) 从当前文本对象中截取从指定起始位置开始到终止位置之前的字符串。 参数：start为被截取部分的起始位置，该数值可为负数；end为被截取部分的终止位置，该数值可为负数。该参数可省略，省略该参数则由起始位置截取至文本对象结尾。 split(‘separator’,limit) 将当前文本对象中与分隔字符相同的字符转为“,”，形成多组字符串，并返回从左开始的指定组数。 参数：separator为分隔字符，分隔字符可以为空，为空时将分隔每个字符为一组；limit为返回组数的数值，该参数可以省略，省略该参数则返回所有字符串组。 substr(start,length) 从当前文本对象中指定起始位置开始截取一定长度的字符串。 参数：start为被截取部分的起始位置；length为被截取部分的长度，该参数可省略，省略该参数则由起始位置截取至文本对象结尾。 substring(from,to) 从当前文本对象中截取从指定位置到另一指定位置区间的字符串。右侧位置不截取。 参数：from为指定区间的起始位置；to为指定区间的终止位置，该参数可省略，省略该参数则由起始位置截取至文本对象结尾。 toLowerCase() 将文本对象中所有的大写字母转换为小写字母。 toUpperCase() 将当前文本对象中所有的小写字母转换为大写字母。 trim() 去除当前文本对象两端的空格。 toString() 将一个逻辑值转换为字符串。 九、中继器函数 名称 用途 Repeater 中继器的对象。Item.Repeater即为Item所在的中继器对象。 visibleItemCount 中继器项目列表中可见项的数量。比如：项目列表共有15项，分页显示为每页6项。当项目列表在第1、2页时，可见项数量为6；当项目列表在第3页时，可见项数量为3。 itemCount 获取中继器项目列表的总数量，或者叫加载项数量。默认情况下项目列表的总数量会与中继器数据集中的数据行数量一致，但是，如果进行了筛选，项目列表的总数量则是筛选后的数量，这个数量不受分页影响。 dataCount 获取中继器数据集中数据行的总数量。 pageCount 获取中继器分页的总数量，即能够获取分页后共有多少页。 pageIndex 获取中继器项目列表当前显示内容的页码。 Item 获取数据集一行数据的集合，即数据行的对象。 TargetItem 目标数据行的对象。 Item.列名 获取数据行中指定列的值。 index 获取数据行的索引编号，编号起始为1，由上至下每行递增1。 isFirst 判断数据行是否为第1行；如果是第1行，返回值为“True”，否则为“False”。 isLast 判断数据行是否为最末行；如果是最末行，返回值为“True”，否则为“False”。 isEven 判断数据行是否为偶数行；如果是偶数行，返回值为“True”，否则为“False”。 isOdd 判断数据行是否为奇数行；如果是奇数行，返回值为“True”，否则为“False”。 isMarked 判断数据行是否为被标记；如果被标记，返回值为“True”，否则为“False”。 isVisible 判断数据行是否为可见行；如果是可见行，返回值为“True”，否则为“False”。 ","permalink":"https://aixin.me/post/axure-advanced-tutorial/","summary":"在axure交互设计时，函数可以用在条件公式和需要赋值的地方，其基本语法是用双方括号包含，变量值和函数用英文句号连接。\n例如：[[LVAR. Width]] 表示变量LVAR的宽度，[[This. Width]] 当前元件的宽度\n一、元件函数 名称 用途 This 获取当前元件对象。当前元件是指当前添加交互动作的元件 Target 获取目标元件对象。目标元件是指当前交互动作控制的元件。 x 获取元件对象的X轴坐标值。 y 获取元件对象的Y轴坐标值。 width 获取元件对象的宽度值 scrollX 获取元件对象的水平滚动距离（当前仅限动态面板） scrollY 获取元件对象的垂直滚动距离（当前仅限动态面板） text 获取元件对象的文本文字 name 获取元件对象的自定义名称。 top 获取元件对象的上边界坐标值。 left 获取元件对象的左边界坐标值。 right 获取元件对象的右边界坐标值。 bottom 获取元件对象的下边界坐标值。 opacity 获取元件对象的不透明比例。 rotation 获取元件对象的旋转角度。 二、鼠标指针函数 名称 用途 Cursor.x 鼠标指针在页面中位置的X轴坐标。 Cursor.y 鼠标指针在页面中位置的Y轴坐标。 DragX 鼠标指针沿X轴拖动元件时的瞬间(0.01秒)拖动距离。 DragY 鼠标指针沿Y轴拖动元件时的瞬间(0.01秒)拖动距离。 TotalDragX 鼠标指针拖动元件从开始到结束的X轴移动距离。 TotalDragY 鼠标指针拖动元件从开始到结束的Y轴移动距离。 DragTime 鼠标指针拖动元件从开始到结束的总时长。 三、窗口函数 名称 用途 Window.width 打开原型页面的浏览器当前宽度。 Window.height 打开原型页面的浏览器当前高度。 Window.scrollX 浏览器中页面水平滚动的距离。 Window.scrollY 浏览器中页面垂直滚动的距离。 四、页面函数 名称 用途 PageName 获取当前页面的名称。 五、数字函数 名称 用途 toExponential(decimalPoints) 用途：值转换为指数计数法。参数：decimalPoints为保留小数的位数。 toFixed(decimalPoints) 用途：将一个数字转为保留指定位数的小数，小数位数超出指定位数时进行四舍五入。参数：decimalPoints为保留小数的位数。 toPrecision(length) 用途：把数字格式化为指定的长度。参数：length为格式化后的数字长度，小数点不计入长度。 六、数学函数 名称 用途 Math.","title":"Axure Advanced Tutorial"},{"content":"一、下载地址 https://code.visualstudio.com/\n二、插件推荐 插件名称 功能说明 Chinese (Simplified) Language Pack for Visual Studio Code 中文汉化包 Code Runner 运行代码 beautify 美化代码 Atuo Rename Tag 自动修改标签头尾 Atuo Close Tag 自动补全标签 Path Intellisense 路径提示器 Markdown PDF 将MD转化为PDF Document This 生成注释文档 Color Picker 拾色器 Prettify JSON 格式化JSON CodeSnap 代码截图工具(选中代码右键菜单CodeSnap后,点击相机图标下载图片) Vetur Vue代码工具 eggjs eggjs代码工具 Vscode NestJs Snippets NestJs代码工具 VSCode Great Icons 一套文件图标 Power Mode 打字效果 Bracket Pair Colorizer 给括号分别着色 Indent-Rainbow 多颜色交替缩进 三、主题推荐 主题名称 功能说明 Atom One Dark Theme Atom的样式 Dimmed 黑白灰 四、快捷键 1、通用 General\n按 Press 功能 Function Ctrl + Shift + P，F1 显示命令面板 Show Command Palette Ctrl + P 快速打开 Quick Open Ctrl + Shift + N 新窗口/实例 New window/instance Ctrl + Shift + W 关闭窗口/实例 Close window/instance 2、基础编辑 Basic editing\n按 Press 功能 Function Ctrl+X 剪切行（空选定） Cut line (empty selection) Ctrl+C 复制行（空选定）Copy line (empty selection) Alt+ ↑ / ↓ 向上/向下移动行 Move line up/down Shift+Alt + ↓ / ↑ 向上/向下复制行 Copy line up/down Ctrl+Shift+K 删除行 Delete line Ctrl+Enter 在下面插入行 Insert line below Ctrl+Shift+Enter 在上面插入行 Insert line above Ctrl+Shift+\\ 跳到匹配的括号 Jump to matching bracket Ctrl+] / [ 缩进/缩进行 Indent/outdent line Home 转到行首 Go to beginning of line End 转到行尾 Go to end of line Ctrl+Home 转到文件开头 Go to beginning of file Ctrl+End 转到文件末尾 Go to end of file Ctrl+↑ / ↓ 向上/向下滚动行 Scroll line up/down Alt+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Shift+[ 折叠（折叠）区域 Fold (collapse) region Ctrl+Shift+] 展开（未折叠）区域 Unfold (uncollapse) region Ctrl+K Ctrl+[ 折叠（未折叠）所有子区域 Fold (collapse) all subregions Ctrl+K Ctrl+] 展开（未折叠）所有子区域 Unfold (uncollapse) all subregions Ctrl+K Ctrl+0 折叠（折叠）所有区域 Fold (collapse) all regions Ctrl+K Ctrl+J 展开（未折叠）所有区域 Unfold (uncollapse) all regions Ctrl+K Ctrl+C 添加行注释 Add line comment Ctrl+K Ctrl+U 删除行注释 Remove line comment Ctrl+/ 切换行注释 Toggle line comment Shift+Alt+A 切换块注释 Toggle block comment Alt+Z 切换换行 Toggle word wrap 3、导航 Navigation\n按 Press 功能 Function Ctrl + T 显示所有符号 Show all Symbols Ctrl + G 转到行\u0026hellip; Go to Line\u0026hellip; Ctrl + P 转到文件\u0026hellip; Go to File\u0026hellip; Ctrl + Shift + O 转到符号\u0026hellip; Go to Symbol\u0026hellip; Ctrl + Shift + M 显示问题面板 Show Problems panel F8 转到下一个错误或警告 Go to next error or warning Shift + F8 转到上一个错误或警告 Go to previous error or warning Ctrl + Shift + Tab 导航编辑器组历史记录 Navigate editor group history Alt + ←/→ 返回/前进 Go back / forward Ctrl + M 切换选项卡移动焦点 Toggle Tab moves focus 4、搜索和替换 Search and replace\n按 Press 功能 Function Ctrl + F 查找 Find Ctrl + H 替换 Replace F3 / Shift + F3 查找下一个/上一个 Find next/previous Alt + Enter 选择查找匹配的所有出现 Select all occurences of Find match Ctrl + D 将选择添加到下一个查找匹配 Add selection to next Find match Ctrl + K Ctrl + D 将最后一个选择移至下一个查找匹配项 Move last selection to next Find match Alt + C / R / W 切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word 5、多光标和选择 Multi-cursor and selection\n按 Press 功能 Function Alt +单击 插入光标 Insert cursor Ctrl + Alt +↑/↓ 在上/下插入光标 Insert cursor above / below Ctrl + U 撤消上一个光标操作 Undo last cursor operation Shift + Alt + I 在选定的每一行的末尾插入光标 Insert cursor at end of each line selected Ctrl + I 选择当前行 Select current line Ctrl + Shift + L 选择当前选择的所有出现 Select all occurrences of current selection Ctrl + F2 选择当前字的所有出现 Select all occurrences of current word Shift + Alt + → 展开选择 Expand selection Shift + Alt + ← 缩小选择 Shrink selection Shift + Alt + （拖动鼠标） 列（框）选择 Column (box) selection Ctrl + Shift + Alt +（箭头键） 列（框）选择 Column (box) selection Ctrl + Shift + Alt + PgUp / PgDown 列（框）选择页上/下 Column (box) selection page up/down 6、丰富的语言编辑 Rich languages editing\n按 Press 功能 Function Ctrl + 空格 触发建议 Trigger suggestion Ctrl + Shift + Space 触发器参数提示 Trigger parameter hints Tab Emmet 展开缩写 Emmet expand abbreviation Shift + Alt + F 格式化文档 Format document Ctrl + K Ctrl + F 格式选定区域 Format selection F12 转到定义 Go to Definition Alt + F12 Peek定义 Peek Definition Ctrl + K F12 打开定义到边 Open Definition to the side Ctrl + . 快速解决 Quick Fix Shift + F12 显示引用 Show References F2 重命名符号 Rename Symbol Ctrl + Shift + . /， 替换为下一个/上一个值 Replace with next/previous value Ctrl + K Ctrl + X 修剪尾随空格 Trim trailing whitespace Ctrl + K M 更改文件语言 Change file language 7、编辑器管理 Editor management\n按 Press 功能 Function Ctrl+F4, Ctrl+W 关闭编辑器 Close editor Ctrl+K F 关闭文件夹 Close folder Ctrl+\\ 拆分编辑器 Split editor Ctrl+ 1 / 2 / 3 聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group Ctrl+K Ctrl+ ←/→ 聚焦到上一个/下一个编辑器组 Focus into previous/next editor group Ctrl+Shift+PgUp / PgDown 向左/向右移动编辑器 Move editor left/right Ctrl+K ← / → 移动活动编辑器组 Move active editor group 8、文件管理 File management\n按 Press 功能 Function Ctrl+N 新文件 New File Ctrl+O 打开文件\u0026hellip; Open File\u0026hellip; Ctrl+S 保存 Save Ctrl+Shift+S 另存为\u0026hellip; Save As\u0026hellip; Ctrl+K S 全部保存 Save All Ctrl+F4 关闭 Close Ctrl+K Ctrl+W 关闭所有 Close All Ctrl+Shift+T 重新打开关闭的编辑器 Reopen closed editor Ctrl+K 输入保持打开 Enter Keep Open Ctrl+Tab 打开下一个 Open next Ctrl+Shift+Tab 打开上一个 Open previous Ctrl+K P 复制活动文件的路径 Copy path of active file Ctrl+K R 显示资源管理器中的活动文件 Reveal active file in Explorer Ctrl+K O 显示新窗口/实例中的活动文件 Show active file in new window/instance 9、显示 Display\n按 Press 功能 Function F11 切换全屏 Toggle full screen Shift+Alt+1 切换编辑器布局 Toggle editor layout Ctrl+ = / - 放大/缩小 Zoom in/out Ctrl+B 切换侧栏可见性 Toggle Sidebar visibility Ctrl+Shift+E 显示浏览器/切换焦点 Show Explorer / Toggle focus Ctrl+Shift+F 显示搜索 Show Search Ctrl+Shift+G 显示Git Show Git Ctrl+Shift+D 显示调试 Show Debug Ctrl+Shift+X 显示扩展 Show Extensions Ctrl+Shift+H 替换文件 Replace in files Ctrl+Shift+J 切换搜索详细信息 Toggle Search details Ctrl+Shift+C 打开新命令提示符/终端 Open new command prompt/terminal Ctrl+Shift+U 显示输出面板 Show Output panel Ctrl+Shift+V 切换Markdown预览 Toggle Markdown preview Ctrl+K V 从旁边打开Markdown预览 Open Markdown preview to the side 10、调试 Debug\n按 Press 功能 Function F9 切换断点 Toggle breakpoint F5 开始/继续 Start/Continue Shift+F5 停止 Stop F11 / Shift+F11 下一步/上一步 Step into/out F10 跳过 Step over Ctrl+K Ctrl+I 显示悬停 Show hover 11、集成终端 Integrated terminal\n按 Press 功能 Function Ctrl+` 显示集成终端 Show integrated terminal Ctrl+Shift+` 创建新终端 Create new terminal Ctrl+Shift+C 复制选定 Copy selection Ctrl+Shift+V 粘贴到活动端子 Paste into active terminal Ctrl+↑ / ↓ 向上/向下滚动 Scroll up/down Shift+PgUp / PgDown 向上/向下滚动页面 Scroll page up/down Ctrl+Home / End 滚动到顶部/底部 Scroll to top/bottom ","permalink":"https://aixin.me/post/visual-studio-code-tutorial/","summary":"一、下载地址 https://code.visualstudio.com/\n二、插件推荐 插件名称 功能说明 Chinese (Simplified) Language Pack for Visual Studio Code 中文汉化包 Code Runner 运行代码 beautify 美化代码 Atuo Rename Tag 自动修改标签头尾 Atuo Close Tag 自动补全标签 Path Intellisense 路径提示器 Markdown PDF 将MD转化为PDF Document This 生成注释文档 Color Picker 拾色器 Prettify JSON 格式化JSON CodeSnap 代码截图工具(选中代码右键菜单CodeSnap后,点击相机图标下载图片) Vetur Vue代码工具 eggjs eggjs代码工具 Vscode NestJs Snippets NestJs代码工具 VSCode Great Icons 一套文件图标 Power Mode 打字效果 Bracket Pair Colorizer 给括号分别着色 Indent-Rainbow 多颜色交替缩进 三、主题推荐 主题名称 功能说明 Atom One Dark Theme Atom的样式 Dimmed 黑白灰 四、快捷键 1、通用 General","title":"Visual Studio Code Tutorial"},{"content":"2021年祝大家春节愉快，牛年大吉！ 艰难的一年过去了，未来或许更加艰难，也或许越来越好，但任何时候依然要不忘初心，努力奋斗。\n2021年目标 专注最重要的事情，做精做好 多些远谋，少些近虑 放下该放下的 ","permalink":"https://aixin.me/post/2021-spring-festivald/","summary":"2021年祝大家春节愉快，牛年大吉！ 艰难的一年过去了，未来或许更加艰难，也或许越来越好，但任何时候依然要不忘初心，努力奋斗。\n2021年目标 专注最重要的事情，做精做好 多些远谋，少些近虑 放下该放下的 ","title":"2021年祝大家春节愉快，牛年大吉！"},{"content":" 本文状态：未完成\n一、产品原型 参考 Windows todo设计一个简单的移动端todo页面原型\n二、开发教程 1、新建Todolist.vue 先通过脚手架配置好vue项目：@vue/cli\n在项目src\\views下面新建Todo.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Todolist\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;content\u0026#34; @keypress=\u0026#34;add\u0026#34;\u0026gt;\u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{content}}\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;section-title\u0026#34;\u0026gt;待办\u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026#34;todolist underway\u0026#34;\u0026gt; \u0026lt;TodoItem :=\u0026#34;todo\u0026#34; v-for=\u0026#34;todo in underway\u0026#34; :key=\u0026#34;todo.id\u0026#34; :class=\u0026#34;{done:todo.status}\u0026#34; v-model=\u0026#34;todo.status\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;section-title\u0026#34;\u0026gt;已完成\u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026#34;todolist completed\u0026#34;\u0026gt; \u0026lt;TodoItem :=\u0026#34;todo\u0026#34; v-for=\u0026#34;todo in completed\u0026#34; :key=\u0026#34;todo.id\u0026#34; :class=\u0026#34;{done:todo.status}\u0026#34; v-model=\u0026#34;todo.status\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import TodoItem from \u0026#39;../components/TodoItem\u0026#39;; export default { name: \u0026#34;Todo\u0026#34;, components:{ TodoItem }, data(){ return{ content:\u0026#39;hello world!\u0026#39;, checked:\u0026#39;\u0026#39;, todos:[ { id:1, content:\u0026#39;这是内容1\u0026#39;, status:false }, { id:2, content:\u0026#39;这是内容2\u0026#39;, status:true }, { id:3, content:\u0026#39;这是内容3\u0026#39;, status:true }, { id:4, content:\u0026#39;这是内容4\u0026#39;, status:false }, { id:5, content:\u0026#39;这是内容5\u0026#39;, status:true } ], } }, methods:{ add(){ this.todos.push({ id:this.todos.length+1, content:this.content, status:false }) } }, computed:{ underway(){ return this.todos.filter(todos=\u0026gt;!todos.status); }, completed(){ return this.todos.filter(todos=\u0026gt;todos.status); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .section-title{font-weight: bold;font-size: 18px;} .todolist li{list-style: none;} .todolist li.done{text-decoration:line-through; } \u0026lt;/style\u0026gt; 2、添加组件 \u0026lt;template\u0026gt; \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; :name=\u0026#34;id\u0026#34; :id=\u0026#34;id\u0026#34; :value=\u0026#34;content\u0026#34; :checked=\u0026#34;modelValue\u0026#34; @input=\u0026#34;onInput\u0026#34;/\u0026gt; \u0026lt;label :for=\u0026#34;id\u0026#34;\u0026gt;{{content}}\u0026lt;/label\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;TodoItem\u0026#34;, data(){ return{ } }, props:{ id:Number, content:String, modelValue:Boolean }, methods:{ onInput(e){ this.$emit(\u0026#39;update:modelValue\u0026#39;,e.target.checked); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 2、添加路由 router\\index.js中添加\nconst routes = [ //... { path: \u0026#39;/todo\u0026#39;, name: \u0026#39;Todo\u0026#39;, component: ()=\u0026gt; import(\u0026#39;../views/Todo\u0026#39;) } 3、入口文件增加Todo页面入口（可以不要这一步） App.vue 文件\n\u0026lt;router-link to=\u0026#34;/todo\u0026#34;\u0026gt;Todo\u0026lt;/router-link\u0026gt; // router-view 公用的不用多次添加 \u0026lt;router-view/\u0026gt; 4、预览页面 现在就可以npm run serve运行查看，\n打开首页后，点击Todo就可以打开todo页面，也可以直接在浏览器输入下面地址查看\nhttp://localhost:8080/todo\n四、备注 父子组件相互传递数据\n==单条参数==\n\u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;{{ name }}\u0026lt;/p\u0026gt; \u0026lt;TodoItem v-model=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Son from \u0026#39;../components/Son\u0026#39;; export default { name: \u0026#34;Father\u0026#34;, components:{ Son }, data(){ return{ name:\u0026#39;Ketty\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;onInput\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Son\u0026#34;, props:{ modelValue:String }, methods:{ onInput(e){ this.$emit(\u0026#39;update:modelValue\u0026#39;,e.target.value); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; ==多条参数==\n\u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;{{ name }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ addr }}\u0026lt;/p\u0026gt; \u0026lt;TodoItem v-model:name=\u0026#34;name\u0026#34; v-model:addr=\u0026#34;addr\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Son from \u0026#39;../components/Son\u0026#39;; export default { name: \u0026#34;Father\u0026#34;, components:{ Son }, data(){ return{ name:\u0026#39;Ketty\u0026#39;, addr:\u0026#34;\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;name\u0026#34; @input=\u0026#34;onNameInput\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;addr\u0026#34; @input=\u0026#34;onAddrInput\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;Son\u0026#34;, props:{ name:String, addr:String }, methods:{ onNameInput(e){ this.$emit(\u0026#39;update:name\u0026#39;,e.target.value); }, onAddrInput(e){ this.$emit(\u0026#39;update:addr\u0026#39;,e.target.value); } } } \u0026lt;/script\u0026gt; ","permalink":"https://aixin.me/post/vue-todo-tutorial/","summary":"本文状态：未完成\n一、产品原型 参考 Windows todo设计一个简单的移动端todo页面原型\n二、开发教程 1、新建Todolist.vue 先通过脚手架配置好vue项目：@vue/cli\n在项目src\\views下面新建Todo.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Todolist\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;content\u0026#34; @keypress=\u0026#34;add\u0026#34;\u0026gt;\u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{content}}\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;section-title\u0026#34;\u0026gt;待办\u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026#34;todolist underway\u0026#34;\u0026gt; \u0026lt;TodoItem :=\u0026#34;todo\u0026#34; v-for=\u0026#34;todo in underway\u0026#34; :key=\u0026#34;todo.id\u0026#34; :class=\u0026#34;{done:todo.status}\u0026#34; v-model=\u0026#34;todo.status\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;section-title\u0026#34;\u0026gt;已完成\u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026#34;todolist completed\u0026#34;\u0026gt; \u0026lt;TodoItem :=\u0026#34;todo\u0026#34; v-for=\u0026#34;todo in completed\u0026#34; :key=\u0026#34;todo.id\u0026#34; :class=\u0026#34;{done:todo.status}\u0026#34; v-model=\u0026#34;todo.status\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import TodoItem from \u0026#39;../components/TodoItem\u0026#39;; export default { name: \u0026#34;Todo\u0026#34;, components:{ TodoItem }, data(){ return{ content:\u0026#39;hello world!\u0026#39;, checked:\u0026#39;\u0026#39;, todos:[ { id:1, content:\u0026#39;这是内容1\u0026#39;, status:false }, { id:2, content:\u0026#39;这是内容2\u0026#39;, status:true }, { id:3, content:\u0026#39;这是内容3\u0026#39;, status:true }, { id:4, content:\u0026#39;这是内容4\u0026#39;, status:false }, { id:5, content:\u0026#39;这是内容5\u0026#39;, status:true } ], } }, methods:{ add(){ this.","title":"Vue3 开发 Todolist 教程"},{"content":" 本页内容基于VUE3.2版本，且以组合式API模式编写\u0026lt;script setup\u0026gt;\n推荐的 IDE 配置是 Visual Studio Code + Volar 扩展\n中文文档：https://staging-cn.vuejs.org/\n使用Vite安装Vue npm init vite@latest \u0026lt;project-name\u0026gt; -- --template vue # 或者 npm create vite@latest \u0026lt;project-name\u0026gt; -- --template vue cd \u0026lt;project-name\u0026gt; npm install npm run dev 模板语法 // 显示文本 \u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; // 显示原始HTML \u0026lt;p\u0026gt;Using v-html directive: \u0026lt;span v-html=\u0026#34;rawHtml\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; // 绑定HTML属性 \u0026lt;div v-bind:id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 绑定多个HTML属性 \u0026lt;div v-bind=\u0026#34;objectOfAttrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 调用函数 \u0026lt;span :title=\u0026#34;toTitleDate(date)\u0026#34;\u0026gt; {{ formatDate(date) }} \u0026lt;/span\u0026gt; // 绑定动态参数 \u0026lt;a v-bind:[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;a v-on:[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; // 如果需要操作[\u0026#39;foo\u0026#39; + bar]，建议使用计算属性 // 修饰符 \u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt;...\u0026lt;/form\u0026gt; // 绑定多个HTML属性 const objectOfAttrs = { id: \u0026#39;container\u0026#39;, class: \u0026#39;wrapper\u0026#39; } 简写：\nv-bind简写为:\nv-on简写为@\n响应式 \u0026lt;script setup\u0026gt; import { ref,reactive } from \u0026#39;vue\u0026#39;; const count = ref(0); console.log(count.value) // 0 // ref声明的对象，在程序内使用需要加.value const count1 = $ref(0); console.log(count1) // 0 // 使用$ref声明响应式对象，使用时无需.value const state = reactive({ num:0 }); console.log(state.num) // 0 function increment() { state.num++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; {{ state.num }} \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{{count}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 计算属性 与方法的区别：计算属性值会基于响应式依赖关系被缓存，只在响应式依赖更新时才会重新计算，重新渲染时不会被更新\n计算属性格式：\nimport { ref,reactive,computed } from \u0026#39;vue\u0026#39; const state = reactive({ num:0 }); //计算属性 const count = computed(()=\u0026gt;{ return state.num \u0026gt; 0 ? \u0026#39;Yes\u0026#39; : \u0026#39;No\u0026#39;; }); // 模板中使用：{{ count }} //对应方法 function count(){ return state.num \u0026gt; 0 ? \u0026#39;Yes\u0026#39; : \u0026#39;No\u0026#39;; } // 模板中使用：{{ count() }} 计算属性被是为“临时快照”，返回的值是派生状态，默认使用get方法，也可以使用set方法来更新更新派生值，不要在计算属性中通过异步请求修改原始值\n条件渲染 \u0026lt;p v-if=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-show\u0026gt;\u0026lt;/p\u0026gt; // v-show只修改元素的display，依然会保留元素，但v-if不会保留 列表渲染 v-for是用来将数据渲染到列表\n\u0026lt;li v-for=\u0026#34;item in items\u0026#34;\u0026gt; {{ item.message }} \u0026lt;/li\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34;\u0026gt; //item 单项别名 // index 单项索引 \u0026lt;/li\u0026gt; 对应JavaScript代码\nconst items = []; items.forEach((item.index)=\u0026gt;{ //... }); 循环整数\n\u0026lt;span v-for=\u0026#34;n in 10\u0026#34;\u0026gt;{{ n }}\u0026lt;/span\u0026gt; v-for也可以遍历对象\n\u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;value in myObject\u0026#34;\u0026gt; {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key) in myObject\u0026#34;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key, index) in myObject\u0026#34;\u0026gt; {{ index }}. {{ key }}: {{ value }} \u0026lt;/li\u0026gt; template上使用v-for\n\u0026lt;ul\u0026gt; \u0026lt;template v-for=\u0026#34;item in items\u0026#34;\u0026gt; \u0026lt;li\u0026gt;{{ item.msg }}\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;divider\u0026#34; role=\u0026#34;presentation\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; 通过key管理状态\n如果是简单的列表，vue会自动将index作为key，如果复杂的列表需要单独设置一个唯一key，唯一key可以保证每次更新只更新单个元素而非整个列表\n\u0026lt;div v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!-- 内容 --\u0026gt; \u0026lt;/div\u0026gt; 组件上使用v-for\n\u0026lt;my-component v-for=\u0026#34;(item, index) in items\u0026#34; :item=\u0026#34;item\u0026#34; :index=\u0026#34;index\u0026#34; :key=\u0026#34;item.id\u0026#34; \u0026gt;\u0026lt;/my-component\u0026gt; 必须将item以prop形式传给子组件，子组件才可以使用\n过滤或排序\n使用计算属性预先处理原始数据即可 JavaScript常见变更数组方法：push()、pop()、shift()、unshift()、splice()、sort()、reverse() 不变更数据方法：filter()，concat() 和 slice()\n事件处理 事件监听： v-on:click=\u0026quot;methodName\u0026quot; 或 @click=\u0026quot;handler\u0026quot;\n内联事件\nconst count = ref(0) \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;Add 1\u0026lt;/button\u0026gt; 方式事件\nfunction say(message) { alert(message) } \u0026lt;button @click=\u0026#34;say(\u0026#39;hello\u0026#39;)\u0026#34;\u0026gt;Say hello\u0026lt;/button 事件修饰符\n.stop .prevent .self .capture .once .passive \u0026lt;!-- 单击事件将停止传递 --\u0026gt; \u0026lt;a @click.stop=\u0026#34;doThis\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 按键修饰符\n.enter .tab .delete (捕获“Delete”和“Backspace”两个按键) .esc .space .up .down .left .right \u0026lt;!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` --\u0026gt; \u0026lt;input @keyup.enter=\u0026#34;submit\u0026#34; /\u0026gt; 系统按键修饰符\n.ctrl .alt .shift .meta \u0026lt;!-- Alt + Enter --\u0026gt; \u0026lt;input @keyup.alt.enter=\u0026#34;clear\u0026#34; /\u0026gt; \u0026lt;!-- Ctrl + 点击 --\u0026gt; \u0026lt;div @click.ctrl=\u0026#34;doSomething\u0026#34;\u0026gt;Do something\u0026lt;/div\u0026gt; 鼠标按键修饰符\n.left .right .middle 表单输入绑定 基本用法\n// 文本 \u0026lt;input v-model=\u0026#34;message\u0026#34; /\u0026gt; // 多行文本 \u0026lt;textarea v-model=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; // 复选框 const checked = ref(true) \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checked\u0026#34; /\u0026gt; // 如果将checked设置为数组，且多个input绑定了checked，则选中的结果或存放在checked数组中,const checkedNames = ref([]) // 单选框 const picked = ref(\u0026#39;One\u0026#39;) \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;one\u0026#34; value=\u0026#34;One\u0026#34; v-model=\u0026#34;picked\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;one\u0026#34;\u0026gt;One\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;two\u0026#34; value=\u0026#34;Two\u0026#34; v-model=\u0026#34;picked\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;two\u0026#34;\u0026gt;Two\u0026lt;/label\u0026gt; // 下拉框单选 const selected = ref(\u0026#39;\u0026#39;) \u0026lt;select v-model=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;option disabled value=\u0026#34;\u0026#34;\u0026gt;Please select one\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; // 下拉多选 const selected = ref([]) \u0026lt;select v-model=\u0026#34;selected\u0026#34; multiple\u0026gt; \u0026lt;option\u0026gt;A\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;B\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;C\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Vue组件 使用组件\n// 子组件 Bar.vue \u0026lt;script setup\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;这是子组件\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; // 父组件 Foo.vue \u0026lt;script setup\u0026gt; import Bar from \u0026#39;./Bar.vue\u0026#39; //引入子组件 \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;这是父组件\u0026lt;/h1\u0026gt; \u0026lt;Bar /\u0026gt; // 使用子组件 \u0026lt;/template\u0026gt; 传递props\n用于父组件给子组件传递值\n\u0026lt;!-- 子组件：BlogPost.vue --\u0026gt; \u0026lt;script setup\u0026gt; defineProps([\u0026#39;title\u0026#39;]) //生命参数 // const props = defineProps([\u0026#39;title\u0026#39;]) // console.log(props.title) // 限制格式 // defineProps({ // title: String, // likes: Number //}}) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h4\u0026gt;{{ title }}\u0026lt;/h4\u0026gt; \u0026lt;!-- 使用参数 --\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 父组件：Blog.vue，将值传给参数title --\u0026gt; \u0026lt;BlogPost title=\u0026#34;My journey with Vue\u0026#34; /\u0026gt; 监听事件\n父组件监听子组件事件（将子组件事件传给父组件）\n方法1：使用$emit方法监听事件\n使用$emit声明一个事件，然后在父组件中监听这个事件，当事件触发后父组件执行相应的其它事件\n// 父组件 \u0026lt;BlogPost ... @do=\u0026#34;doSomething\u0026#34; /\u0026gt; // 子组件 \u0026lt;button @click=\u0026#34;$emit(\u0026#39;do\u0026#39;)\u0026#34;\u0026gt;Do Something\u0026lt;/button\u0026gt; //\u0026lt;button @click=\u0026#34;$emit(\u0026#39;do\u0026#39;,\u0026#39;传给父组件的内容\u0026#39;,\u0026#39;...\u0026#39;)\u0026#34;\u0026gt;Do Something\u0026lt;/button\u0026gt; 方法2：使用defineEmits监听子组件事件，并获取回传的参数值\n// 父组件 function doSomething(data){ alert(data) //data:回传的值 } \u0026lt;BlogPost ... @do=\u0026#34;doSomething\u0026#34; /\u0026gt; // 子组件 const emit = defineEmits([\u0026#39;do\u0026#39;]) const do = ()=\u0026gt;{ emit(\u0026#39;do\u0026#39;,\u0026#39;回传的值\u0026#39;) } \u0026lt;button @click=\u0026#34;do\u0026#34;\u0026gt;Do Something\u0026lt;/button\u0026gt; 方法3：组件上使用v-model来实现子父组件之间内容传递\n插槽\n插槽\u0026lt;slot\u0026gt;是占位符，用来在子组件中对应位置显示父组件传递的内容（也可以通过传值的方式来替代插槽）\n// 父组件 \u0026lt;Bar\u0026gt; 这是父组件传递的内容 \u0026lt;/Bar\u0026gt; // 子组件 \u0026lt;p\u0026gt;这是子组件的一部分内容\u0026lt;/p\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;!--这儿会显示父组件传递的内容--\u0026gt; \u0026lt;p\u0026gt;这是子组件的另一部分内容\u0026lt;/p\u0026gt; ","permalink":"https://aixin.me/post/vue3-base-tutorials/","summary":"本页内容基于VUE3.2版本，且以组合式API模式编写\u0026lt;script setup\u0026gt;\n推荐的 IDE 配置是 Visual Studio Code + Volar 扩展\n中文文档：https://staging-cn.vuejs.org/\n使用Vite安装Vue npm init vite@latest \u0026lt;project-name\u0026gt; -- --template vue # 或者 npm create vite@latest \u0026lt;project-name\u0026gt; -- --template vue cd \u0026lt;project-name\u0026gt; npm install npm run dev 模板语法 // 显示文本 \u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; // 显示原始HTML \u0026lt;p\u0026gt;Using v-html directive: \u0026lt;span v-html=\u0026#34;rawHtml\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; // 绑定HTML属性 \u0026lt;div v-bind:id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 绑定多个HTML属性 \u0026lt;div v-bind=\u0026#34;objectOfAttrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 调用函数 \u0026lt;span :title=\u0026#34;toTitleDate(date)\u0026#34;\u0026gt; {{ formatDate(date) }} \u0026lt;/span\u0026gt; // 绑定动态参数 \u0026lt;a v-bind:[attributeName]=\u0026#34;url\u0026#34;\u0026gt; .","title":"Vue3.2 组合式API基础知识点"},{"content":"一、安装 下面时windows10的安装教程，Linux和MAC去看官方教程\n1、下载 最新版下载地址：https://github.com/gohugoio/hugo/releases\n下载 Windows-64bit.zip\n2、新建本地目录 D:\\Hugo\nD:\\Hugo\\bin\nD:\\Hugo\\Sites\n盘符和目录都可以自定义，但bin和Sites要固定\n将下载的安装包里面的hugo.exe解压到D:\\Hugo\\bin下面\n3、配置环境 我的电脑→右键→高级→环境变量→系统变量→Path，增加D:\\Hugo\\bin\n也可以命令执行：set PATH=%PATH%;D:\\Hugo\\bin\n4、安装完成 验证\nhugo version //查看版本 hugo help //帮助文档 能正常输出即安装成功，如果输出错误，则需要重启电脑后再试\n二、新建网站 在D:\\Hugo\\Sites下面打开cmd，或其他命令工具\nhugo new site simple.com 新建simple.com 网站名自定义\n回车创建成功！\n然后在D:\\Hugo\\Sites下面就会新建一个simple文件夹\n三、编写内容 1、目录说明 archetypes/ 创建页面的原型文件，比如标题时间等，可以自定义\ncontent/ markdown原文件存储目录\nlayouts/ 样式自定义时需要\nstatic/ 静态文件\nthemes/ 主题会安装在这儿\nconfig.toml 配置文件\n2、创建页面 在网站目录下面执行命令\nhugo new about.md 自动在当前网站下的content目录下生成about.md文件\n3、创建文章 hugo new post/hello-world.md 自动在content/post下面生成hello-world.md文件\n新生成的文件自动会有三个字段(这儿的模板可以在archetypes里面的文件修改)：\ntitle: \u0026#34;Hello world\u0026#34; //文件名称 date: 2020-11-03T16:58:08+08:00 //创建日期 draft: true //草稿，默认开启 4、安装主题 在官方主题库中找到喜欢主题，按照教程安装\nhttps://themes.gohugo.io/\n例如： https://themes.gohugo.io/hugo-papermod/\n当前博客用的就是这个主题\n按照主题教程安装即可，建议使用主题推荐的config配置文件 papermod配置\nbaseURL: \u0026#34;https://aixin.me\u0026#34; title: Aixin.me paginate: 5 theme: hugo-PaperMod-5.0 defaultContentLanguage: zh enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false # googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: Aixin.me description: \u0026#34;Aixin.me\u0026#34; author: Aixin # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: false disableSpecial1stPost: false comments: false hidemeta: false showtoc: false tocopen: false assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;/images/favicon.ico\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Aixin.me\u0026#34; icon: iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page # for search fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: about name: About url: /about/ weight: 10 - identifier: archives name: Archives url: /archives/ weight: 10 - identifier: tags name: Tags url: /tags/ weight: 20 - identifier: search name: Search url: /search/ weight: 30 # for search outputs: home: - HTML - RSS - JSON # is necessary 5、本地运行 网站根目录执行：\nhugo server 最后，必须将文章的draft: true改成draft: false才可以在网站上显示出来\n当然，也可以使用hugo server --theme=hyde --buildDrafts，可以指定主题，也可以编译draft: true的文件\n四、发布网站 网站根目录执行：\nhugo --baseUrl=https:simple.com 然后就会将博客发布到public目录下面\n将pubic目录下的文件发布到git上即可\nhttps:simple.com 是目标网址，也可以是simple.github.io\n\u0026ndash;baseUrl是将config文件里面的baseUrl修改为生产环境的地址\n以上全部完毕，只写了基本的用法，更详细的教程请查看官方教程，也可以使用hugo help命令查看帮助文档\n常用命令 //本地预览：http://localhost:1313/ D:\\Hugo\\Sites\\simple.com\u0026gt; hugo server //生成静态文件 D:\\Hugo\\Sites\\simple.com\u0026gt; hugo //push到github D:\\Hugo\\Sites\\simple.com\\public\u0026gt; git push origin master ","permalink":"https://aixin.me/post/how-to-hugo/","summary":"一、安装 下面时windows10的安装教程，Linux和MAC去看官方教程\n1、下载 最新版下载地址：https://github.com/gohugoio/hugo/releases\n下载 Windows-64bit.zip\n2、新建本地目录 D:\\Hugo\nD:\\Hugo\\bin\nD:\\Hugo\\Sites\n盘符和目录都可以自定义，但bin和Sites要固定\n将下载的安装包里面的hugo.exe解压到D:\\Hugo\\bin下面\n3、配置环境 我的电脑→右键→高级→环境变量→系统变量→Path，增加D:\\Hugo\\bin\n也可以命令执行：set PATH=%PATH%;D:\\Hugo\\bin\n4、安装完成 验证\nhugo version //查看版本 hugo help //帮助文档 能正常输出即安装成功，如果输出错误，则需要重启电脑后再试\n二、新建网站 在D:\\Hugo\\Sites下面打开cmd，或其他命令工具\nhugo new site simple.com 新建simple.com 网站名自定义\n回车创建成功！\n然后在D:\\Hugo\\Sites下面就会新建一个simple文件夹\n三、编写内容 1、目录说明 archetypes/ 创建页面的原型文件，比如标题时间等，可以自定义\ncontent/ markdown原文件存储目录\nlayouts/ 样式自定义时需要\nstatic/ 静态文件\nthemes/ 主题会安装在这儿\nconfig.toml 配置文件\n2、创建页面 在网站目录下面执行命令\nhugo new about.md 自动在当前网站下的content目录下生成about.md文件\n3、创建文章 hugo new post/hello-world.md 自动在content/post下面生成hello-world.md文件\n新生成的文件自动会有三个字段(这儿的模板可以在archetypes里面的文件修改)：\ntitle: \u0026#34;Hello world\u0026#34; //文件名称 date: 2020-11-03T16:58:08+08:00 //创建日期 draft: true //草稿，默认开启 4、安装主题 在官方主题库中找到喜欢主题，按照教程安装","title":"静态博客Hugo安装及使用教程"},{"content":"借贷记账法 借贷记账法下，所有账户的结构都是左方为借方，右方为贷方，但借方、贷方反映会计要素数量变化的增减性质则是不固定的。不同性质的账户，借贷方所登记的内容不同，下面分别说明各类账户的结构。\n有借必有贷，借贷必相等\n资产类账户的结构 在资产类账户中，它的借方记录资产的增加额，贷方记录资产的减少额。在同一会计期间（年、月），借方记录的合计数额称作本期借方发生额，贷方记录的合计数称作本期贷方发生额，在每一会计期间的期末将借贷方发生额相比较，其差额称作期末余额。资产类账户的期末余额一般在借方。\n资产类账户的期末余额可根据下列公式计算： 期末余额（借方）= 期初余额 + 本期借方发生额 - 本期贷方发生额\n负债类账户和所有者权益类账户的结构 负债及所有者权益类账户的结构与资产类账户正好相反，其贷方记录负债及所有者权益的增加额；借方记录负债及所有者权益的减少额，期末余额一般应在贷方。\n负债类账户和所有者权益类账户的期末余额可根据下列公式计算： 期末余额（贷方）= 期初余额 + 本期贷方发生额 - 本期借方发生额\n成本费用类账户的结构 成本类账户的结构与资产类账户的结构基本相同，账户的借方记录费用成本的增加额，账户的贷方记录费用成本转入抵销收益类账户（减少）的数额，由于借方记录的费用成本的增加额一般都要通过贷方转出，所以账户通常没有余额。如果有余额，也表现为借方余额。\n收益类账户的结构 收益类账户的结构则与负债类账户和所有者权益类账户的结构基本相同，收入的增加额记入账户的贷方，收入转出（减少额）则应记入账户的借方，由于贷方记录的收入增加额一般要通过借方转出，所以账户通常也没有期末余额。如果有余额，同样也表现为贷方余额。\n","permalink":"https://aixin.me/post/finance-accounting/","summary":"借贷记账法 借贷记账法下，所有账户的结构都是左方为借方，右方为贷方，但借方、贷方反映会计要素数量变化的增减性质则是不固定的。不同性质的账户，借贷方所登记的内容不同，下面分别说明各类账户的结构。\n有借必有贷，借贷必相等\n资产类账户的结构 在资产类账户中，它的借方记录资产的增加额，贷方记录资产的减少额。在同一会计期间（年、月），借方记录的合计数额称作本期借方发生额，贷方记录的合计数称作本期贷方发生额，在每一会计期间的期末将借贷方发生额相比较，其差额称作期末余额。资产类账户的期末余额一般在借方。\n资产类账户的期末余额可根据下列公式计算： 期末余额（借方）= 期初余额 + 本期借方发生额 - 本期贷方发生额\n负债类账户和所有者权益类账户的结构 负债及所有者权益类账户的结构与资产类账户正好相反，其贷方记录负债及所有者权益的增加额；借方记录负债及所有者权益的减少额，期末余额一般应在贷方。\n负债类账户和所有者权益类账户的期末余额可根据下列公式计算： 期末余额（贷方）= 期初余额 + 本期贷方发生额 - 本期借方发生额\n成本费用类账户的结构 成本类账户的结构与资产类账户的结构基本相同，账户的借方记录费用成本的增加额，账户的贷方记录费用成本转入抵销收益类账户（减少）的数额，由于借方记录的费用成本的增加额一般都要通过贷方转出，所以账户通常没有余额。如果有余额，也表现为借方余额。\n收益类账户的结构 收益类账户的结构则与负债类账户和所有者权益类账户的结构基本相同，收入的增加额记入账户的贷方，收入转出（减少额）则应记入账户的借方，由于贷方记录的收入增加额一般要通过借方转出，所以账户通常也没有期末余额。如果有余额，同样也表现为贷方余额。","title":"财会常用知识点"},{"content":"Average True Range 取一定时间周期内的股价波动幅度的移动平均值，通常使用14天。\n由于惊恐抛售所驱使的价格的剧烈下跌，这一指标在市场底部通常可以达到一个较高的价值。这一指标对于长期持续边幅移动的时段是非常典型的，这一情况通常发生在市场的顶部，或者是在价格巩固期间。平均波幅通道技术指标依据同样的原则，可以被解释成为其他一些易变指数。根据这个指标来进行预测的原则可以表达为：该指标价值越高，趋势改变的可能性就越高；该指标的价值越低，趋势的移动性就越弱。\nt：当日tody； p：上一个节点previous n：时间单元unit； Ci：第i日的收盘价close； Hi：第i日的最高价height； Li：第i日的最低价low。\n$$ TR = Max[(H-L),Abs(H-C_p),Abs(L-C_p)] $$\nMax 取最大值 Abs 取绝对值absolute\n$$ ATR = \\Big( \\frac{1}{n}\\Big) \\sum^{(n)}_{(i=1)} TR_i $$\n波动性较高的股票具有较高的ATR，而波动性较低的股票具有较低的ATR。 它的创建是为了使交易者可以通过简单的计算来更准确地衡量资产的每日波动性。该指标未指示价格方向；相反，它主要用于衡量由缺口引起的波动并限制上下波动 ATR的使用通常用作退出方法，无论如何做出进入决定\n可以使用ATR方法来确定头寸规模，从而说明单个交易者自己接受风险的意愿以及基础市场的波动性\nATR使用范围 1、利用ATR资金配比 通过ATR指标的具体数值我们可以看到一些基本的信息,从中分别具体货币的波动情况,这样就可以调整资金的配比.并且每种产品的价格都在不断的波动中,所以可以根据具体的ATR指标的参数来调整交易的计划\n2、利用ATR选择入场点位 短期ATR一般大于长期的ATR,我们可以通过短期和长期的波动性的差值,并根据相应的价格方向入场,同时在趋势比较稳定的时候平仓出局.\n3、利用ATR止损 著名的海龟法则中,海龟交易法则按照价格高于初始价格0.5ATR进行加仓操作,按照价格低于建仓价2ATR进行止损操作.\n","permalink":"https://aixin.me/post/average-true-range/","summary":"Average True Range 取一定时间周期内的股价波动幅度的移动平均值，通常使用14天。\n由于惊恐抛售所驱使的价格的剧烈下跌，这一指标在市场底部通常可以达到一个较高的价值。这一指标对于长期持续边幅移动的时段是非常典型的，这一情况通常发生在市场的顶部，或者是在价格巩固期间。平均波幅通道技术指标依据同样的原则，可以被解释成为其他一些易变指数。根据这个指标来进行预测的原则可以表达为：该指标价值越高，趋势改变的可能性就越高；该指标的价值越低，趋势的移动性就越弱。\nt：当日tody； p：上一个节点previous n：时间单元unit； Ci：第i日的收盘价close； Hi：第i日的最高价height； Li：第i日的最低价low。\n$$ TR = Max[(H-L),Abs(H-C_p),Abs(L-C_p)] $$\nMax 取最大值 Abs 取绝对值absolute\n$$ ATR = \\Big( \\frac{1}{n}\\Big) \\sum^{(n)}_{(i=1)} TR_i $$\n波动性较高的股票具有较高的ATR，而波动性较低的股票具有较低的ATR。 它的创建是为了使交易者可以通过简单的计算来更准确地衡量资产的每日波动性。该指标未指示价格方向；相反，它主要用于衡量由缺口引起的波动并限制上下波动 ATR的使用通常用作退出方法，无论如何做出进入决定\n可以使用ATR方法来确定头寸规模，从而说明单个交易者自己接受风险的意愿以及基础市场的波动性\nATR使用范围 1、利用ATR资金配比 通过ATR指标的具体数值我们可以看到一些基本的信息,从中分别具体货币的波动情况,这样就可以调整资金的配比.并且每种产品的价格都在不断的波动中,所以可以根据具体的ATR指标的参数来调整交易的计划\n2、利用ATR选择入场点位 短期ATR一般大于长期的ATR,我们可以通过短期和长期的波动性的差值,并根据相应的价格方向入场,同时在趋势比较稳定的时候平仓出局.\n3、利用ATR止损 著名的海龟法则中,海龟交易法则按照价格高于初始价格0.5ATR进行加仓操作,按照价格低于建仓价2ATR进行止损操作.","title":"ATR：均幅指标"},{"content":"一、BackTrader介绍 BackTrader是开源免费的量化交易策略回测系统， 运行流程：\n引入backtrader 加载和注入数据Feed（cerebro.adddata） 执行：cerebro.run() 可视化结果：cerebro.plot() 二、安装BackTrader 1、安装环境要求： Python 2.7 Python 3.2 / 3.3/ 3.4 / 3.5 pypy/pypy3 Matplotlib\u0026gt; = 1.4.1（如果需要绘图的话需要配置） 2、兼容Python2.x/3.x from __future__ import (absolute_import, division, print_function,unicode_literals) 3.1、通过pip安装: pip install backtrader\n如果想同时安装matplotlib： pip install backtrader[plotting]\n3.2、通过源安装 https://github.com/mementum/backtrader python安装源文件，自己搜索\n3.3、通过pycharm安装 新建项目 -\u0026gt; Files -\u0026gt; Settings -\u0026gt; Project 项目名称 -\u0026gt; Project Interpreter -\u0026gt; 右侧加号，搜索backtrader Install Package即可\n三、backtrader用法 1、使用前说明 常用数据名称： 开盘价，最高价，最低价，收盘价，成交量，持仓量\n数据索引方式： 当前值：[0] 前一个值：[-1] 前2个值：[-2] ……\n说明：所有的数字都是历史值，所以只能往后推\n1、基本功能 from __future__ import (absolute_import, division, print_function,unicode_literals) #让python2兼容python3，python3环境下可以不用写 #引入backtrader import backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.Cerebro() cerebro.broker.setcash(100.0) #可以自定义金额 print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) cerebro.run() print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) 执行结果：\nStarting Portfolio Value: 100.00\nFinal Portfolio Value: 100.00\n2、添加数据 说明： os.path.dirname 当前文件的绝对路劲目录（不包含文件名） __file__ 当前文件绝对路劲+文件名 os.path.abspath(path) 输出绝对路劲、当前目录、上级目录等（反斜杠） sys.argv[0] 当前文件绝对路劲+文件名（本地目录，正斜杠，用的时候需要转化成反斜杠）\nprint(sys.argv[0]) #输出：D:/python/futures/macd.py\rprint(os.path.abspath(sys.argv[0])) #输出：D:\\python\\futures\\macd.py\rprint(os.path.dirname(os.path.abspath(sys.argv[0]))) #输出：D:\\python\\futures 代码：\nimport datetime # For datetime objects import os.path # To manage paths import sys # To find out the script name (in argv[0]) # Import the backtrader platform import backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: # Create a cerebro entity cerebro = bt.Cerebro() # Datas are in a subfolder of the samples. Need to find where the script is # because it could have been called from anywhere modpath = os.path.dirname(os.path.abspath(sys.argv[0])) datapath = os.path.join(modpath, \u0026#39;../../datas/orcl-1995-2014.txt\u0026#39;) # Create a Data Feed data = bt.feeds.YahooFinanceCSVData( dataname=datapath, # Do not pass values before this date fromdate=datetime.datetime(2000, 1, 1), # Do not pass values after this date todate=datetime.datetime(2000, 12, 31), reverse=False) # Add the Data Feed to Cerebro cerebro.adddata(data) # Set our desired cash start cerebro.broker.setcash(100000.0) # Print out the starting conditions print(\u0026#39;Starting Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) # Run over everything cerebro.run() # Print out the final result print(\u0026#39;Final Portfolio Value: %.2f\u0026#39; % cerebro.broker.getvalue()) 运行结果：\nStarting Portfolio Value: 1000000.00\nFinal Portfolio Value: 1000000.00\n","permalink":"https://aixin.me/post/backtrader/","summary":"一、BackTrader介绍 BackTrader是开源免费的量化交易策略回测系统， 运行流程：\n引入backtrader 加载和注入数据Feed（cerebro.adddata） 执行：cerebro.run() 可视化结果：cerebro.plot() 二、安装BackTrader 1、安装环境要求： Python 2.7 Python 3.2 / 3.3/ 3.4 / 3.5 pypy/pypy3 Matplotlib\u0026gt; = 1.4.1（如果需要绘图的话需要配置） 2、兼容Python2.x/3.x from __future__ import (absolute_import, division, print_function,unicode_literals) 3.1、通过pip安装: pip install backtrader\n如果想同时安装matplotlib： pip install backtrader[plotting]\n3.2、通过源安装 https://github.com/mementum/backtrader python安装源文件，自己搜索\n3.3、通过pycharm安装 新建项目 -\u0026gt; Files -\u0026gt; Settings -\u0026gt; Project 项目名称 -\u0026gt; Project Interpreter -\u0026gt; 右侧加号，搜索backtrader Install Package即可\n三、backtrader用法 1、使用前说明 常用数据名称： 开盘价，最高价，最低价，收盘价，成交量，持仓量\n数据索引方式： 当前值：[0] 前一个值：[-1] 前2个值：[-2] ……\n说明：所有的数字都是历史值，所以只能往后推\n1、基本功能 from __future__ import (absolute_import, division, print_function,unicode_literals) #让python2兼容python3，python3环境下可以不用写 #引入backtrader import backtrader as bt if __name__ == \u0026#39;__main__\u0026#39;: cerebro = bt.","title":"BackTrader学习笔记"},{"content":"MA(Moving Average):移动平均线 可以过滤随机价格波动中的噪音来帮助平滑价格走势，基于过去的价格，因此时趋势跟踪。包括简单移动平均线(SMA)和指数移动平均线(EMA)，常见应用为确定趋势方向并确定支撑位和阻力位\n简单移动平均线(SMA)： $$SMA = \\frac{A_1 + A_2 + \\cdots + A_n}{n}$$ A:n期的平均值 n：周期数\n指数移动平均线(EMA): $$EMA_t = [V_t \\times \\big(\\frac{s}{1+d}\\big)] + EMA_y \\times [1 - \\big(\\frac{s}{1+d}\\big)]$$\n$$EMA_t$$:当天或当期的EMA $$V_t$$:当天或当期的价格值 $$EMA_y$$:昨天或上期的EMA s:平滑度 d:天数或期数\n要计算EMA，线要计算SMA，然后再计算平滑度s 平滑度的计算公式：$$s = \\frac{2}{选定天数+1}$$\nEMA:指数移动平均（考虑了当天收盘价），快EMA（短时期，通常用12周期），慢EMA（长时期，通常用26周期）\n","permalink":"https://aixin.me/post/moving-average/","summary":"MA(Moving Average):移动平均线 可以过滤随机价格波动中的噪音来帮助平滑价格走势，基于过去的价格，因此时趋势跟踪。包括简单移动平均线(SMA)和指数移动平均线(EMA)，常见应用为确定趋势方向并确定支撑位和阻力位\n简单移动平均线(SMA)： $$SMA = \\frac{A_1 + A_2 + \\cdots + A_n}{n}$$ A:n期的平均值 n：周期数\n指数移动平均线(EMA): $$EMA_t = [V_t \\times \\big(\\frac{s}{1+d}\\big)] + EMA_y \\times [1 - \\big(\\frac{s}{1+d}\\big)]$$\n$$EMA_t$$:当天或当期的EMA $$V_t$$:当天或当期的价格值 $$EMA_y$$:昨天或上期的EMA s:平滑度 d:天数或期数\n要计算EMA，线要计算SMA，然后再计算平滑度s 平滑度的计算公式：$$s = \\frac{2}{选定天数+1}$$\nEMA:指数移动平均（考虑了当天收盘价），快EMA（短时期，通常用12周期），慢EMA（长时期，通常用26周期）","title":"MA/SMA/EMA"},{"content":"算数平均数 一组数据的所有数据之和除以数据个数，反映数据集中的趋势 $$ A_n = \\frac{a_1+a_2+a_3+\\cdots+a_n}{n} $$\n几何平均数 n数连续乘积，然后开n次方根 $$ G_n = \\sqrt[n]{a_1 \\times a_2 \\times a_3 \\times \\cdots \\times a_n} $$\n调和平均数（数学，非统计） 每一个数值取倒数，然后将所有倒数求平均，然后将得到的平均数取到数 $$ H_n = \\frac{n}{\\frac{1}{a_1} + \\frac{1}{a_2} \\frac{1}{a_3} + \\cdots + \\frac{1}{a_n}} $$\n加权平均数 如果是一个含有重复数据的数组n，所有数的合除以所有数重复出现的总次数， 数字$x_n$出现的次数是$f_n$ $$ n = f_1 + f_2 + f_3 + \\cdots + f_n $$ $$ \\overline{X} = \\frac{x_1 \\times f_1 + x_2 \\times f_2 + x_3 \\times f_3 + \\cdots + x_n \\times f_n}{n} $$\n平方平均数 n个数据先单个平方，再整体平均，最后再开平方 $$ M_n = \\sqrt{\\frac{a^2_1+a^2_2+a^2_3+ \\cdots +a^2_n}{n}} $$\n指数平均数(EXPMA,简称EMA) 对序列 ${x_n}$ 定义其截至第 n 项的周期为N 的指数移动平均 $EMA_N(x_n)$ 为 $$ EMA_N(x_n) = \\frac{2}{N + 1} \\sum^{\\infty}_{k=0} \\bigg(\\frac{N - 1}{N + 1}\\bigg)^k x_n-k $$\n中位数 $$X_1,X_2,X_3,\\cdots,X_n$$是总体样本，然后按照从小到大排序： $$X_{(1)},X_{(2)},X_{(3)}\\cdots,X_{(n)}$$\nn为奇数时：$$m_{0.5} = X_{\\frac{n+1}{2}}$$\nn为偶数时：$$m_{0.5}= \\frac{X_{(n/2)}+X_{(n/2+1)}}{2}$$\n","permalink":"https://aixin.me/post/average/","summary":"算数平均数 一组数据的所有数据之和除以数据个数，反映数据集中的趋势 $$ A_n = \\frac{a_1+a_2+a_3+\\cdots+a_n}{n} $$\n几何平均数 n数连续乘积，然后开n次方根 $$ G_n = \\sqrt[n]{a_1 \\times a_2 \\times a_3 \\times \\cdots \\times a_n} $$\n调和平均数（数学，非统计） 每一个数值取倒数，然后将所有倒数求平均，然后将得到的平均数取到数 $$ H_n = \\frac{n}{\\frac{1}{a_1} + \\frac{1}{a_2} \\frac{1}{a_3} + \\cdots + \\frac{1}{a_n}} $$\n加权平均数 如果是一个含有重复数据的数组n，所有数的合除以所有数重复出现的总次数， 数字$x_n$出现的次数是$f_n$ $$ n = f_1 + f_2 + f_3 + \\cdots + f_n $$ $$ \\overline{X} = \\frac{x_1 \\times f_1 + x_2 \\times f_2 + x_3 \\times f_3 + \\cdots + x_n \\times f_n}{n} $$","title":"常用平均数"},{"content":"MACD原理介绍 MACD(Moving Average Convergence Divergence),是根据均线的构造原理，对股票价格的收盘价进行平滑处理，求出算术平均值以后再进行计算，是一种趋向类指标。\nMACD指标是运用快速（短期）和慢速（长期）移动平均线及其聚合与分离的征兆，加以双重平滑运算。而根据移动平均线原理发展出来的MACD，一则去除了移动平均线频繁发出假信号的缺陷，二则保留了移动平均线的效果，因此，MACD指标具有均线趋势性、稳重性、安定性等特点，是用来研判买卖股票的时机，预测股票价格涨跌的技术分析指标 。\nMACD指标主要是通过EMA、DIF和DEA（或叫MACD、DEM）这三值之间关系的研判，DIF和DEA连接起来的移动平均线的研判以及DIF减去DEM值而绘制成的柱状图（BAR）的研判等来分析判断行情，预测股价中短期趋势的主要的股市技术分析指标。其中，DIF是核心，DEA是辅助。DIF是快速平滑移动平均线（EMA1）和慢速平滑移动平均线（EMA2）的差。BAR柱状图在股市技术软件上是用红柱和绿柱的收缩来研判行情。 价格数据：收盘价close EMA：指数移动平均线 DIF（差离值） = EMA12日线 - EMA26日线 EMA9：是“信号线”，又称DEA DIF线与EMA9日线比较，DIF穿越到EMA9上方是买入或做多信号，DIF穿越到EMA9的下方为卖出或做空信号， DIF值越大，上涨趋势越大，DIF值越小，下跌趋势越大\n柱状图：(DIF-DEA)*2\n解释方法：交叉、散度、快速上升/下降\nRSI相对强度指标（振荡器），范围是0到100，超过70时，是为超买或高估，可能引发趋势翻转或价格回调，小于30时，视为超卖或低估。\nMACD计算方式 DMA:平行线差指标\n","permalink":"https://aixin.me/post/macd/","summary":"MACD原理介绍 MACD(Moving Average Convergence Divergence),是根据均线的构造原理，对股票价格的收盘价进行平滑处理，求出算术平均值以后再进行计算，是一种趋向类指标。\nMACD指标是运用快速（短期）和慢速（长期）移动平均线及其聚合与分离的征兆，加以双重平滑运算。而根据移动平均线原理发展出来的MACD，一则去除了移动平均线频繁发出假信号的缺陷，二则保留了移动平均线的效果，因此，MACD指标具有均线趋势性、稳重性、安定性等特点，是用来研判买卖股票的时机，预测股票价格涨跌的技术分析指标 。\nMACD指标主要是通过EMA、DIF和DEA（或叫MACD、DEM）这三值之间关系的研判，DIF和DEA连接起来的移动平均线的研判以及DIF减去DEM值而绘制成的柱状图（BAR）的研判等来分析判断行情，预测股价中短期趋势的主要的股市技术分析指标。其中，DIF是核心，DEA是辅助。DIF是快速平滑移动平均线（EMA1）和慢速平滑移动平均线（EMA2）的差。BAR柱状图在股市技术软件上是用红柱和绿柱的收缩来研判行情。 价格数据：收盘价close EMA：指数移动平均线 DIF（差离值） = EMA12日线 - EMA26日线 EMA9：是“信号线”，又称DEA DIF线与EMA9日线比较，DIF穿越到EMA9上方是买入或做多信号，DIF穿越到EMA9的下方为卖出或做空信号， DIF值越大，上涨趋势越大，DIF值越小，下跌趋势越大\n柱状图：(DIF-DEA)*2\n解释方法：交叉、散度、快速上升/下降\nRSI相对强度指标（振荡器），范围是0到100，超过70时，是为超买或高估，可能引发趋势翻转或价格回调，小于30时，视为超卖或低估。\nMACD计算方式 DMA:平行线差指标","title":"MACD 平滑异同移动平均指标"},{"content":"一、凯利公式 英文：The Kelly Criterion\n在概率论中，凯利公式（也称 “凯利方程式”）是一个在期望净收益为正的独立重复赌局中，使本金的长期增长率最大化的投注策略。该公式于 1956 年由约翰·拉里·凯利（John Larry Kelly）在《贝尔系统技术期刊》中发表，可以用来计算每次游戏中应投注的资金比例。若赌局的期望净收益为零或为负，凯利公式给出的结论是不赌为赢。\n公式： $$ f^* = \\frac {bp-q}{b} = \\frac {p(b+1)-1}{b} $$\n$f^*$ = 应投注的资本比值 p = 获胜的概率 q = 失败的概率 b = 赔率\n例子：有一个简单2赔1的赌局，扔硬币下注，硬币为正面则得2元，如果为反面则输掉1元，你的总资产为100元，每一次的押注都可投入任意金额。你会怎么赌呢？\n硬币抛出正反面的概率都是50%，所以p、q获胜失败的概率都为0.5，而赔率＝期望盈利÷可能亏损=2元盈利÷1元亏损，赔率就是2，我们要求的答案是f，也就是(bp - q) ÷ b = (2 * 50% - 50%) ÷ 2 = 25%。拿出资金的25%来进行下注，才能使赌局收益最大化。\n真正应该关心的是长期累积的收入，对于累积的收益来说，最后的结果只和输赢的局数有关，而和输赢的顺序无关。所以凯利公式推出了一个最佳的投入仓位比，来最大化长期的累积收益： $$ bet = edge / odds $$\n最佳仓位bet = 预期获益 / 获益回报 edge：赢面 odds：赔率\n$$ edge = bp - q $$\n赢面 = 获胜的概率*赔率 - 失败的概率\n小明现在有100元的起始资金，他现在将要投硬币4次，每一次他投出硬币为正面的时候，将获得6倍资金回报(1陪5)，当他投出硬币为反面，陪光。请问小明要如何分配每次下注资金，才能最大化他4次投币之后的收益呢？\nedge = 0.5 * 5 - 0.5 = 2 odds = 5 最佳仓位bet = 2/5 = 40%\n根据凯利公式计算，我们可以建立起这样一个正反面的概率各为50%，edge = 0.5*5-0.5 = 2, odds为5，最佳仓位为40%，可以看到最终在16个可能出现的结果中(4次投掷)，12.96和8100出现1次，64.8和1620出现4次，324出现6次，16次结果的收益为324。凯利公式的目的正是最大化这些结果的收益。\n参考：https://www.gfedu.cn/aqf/content_23580.shtml\n二、CTA策略 商品交易顾问(CommodityTrading Advisor) CTA是一种获取绝对收益的资产管理方式或投资策略。初始定义来自美国商品期货交易委员会(CFTC)制定的商品交易法案，是指通过为客户提供期货期权方面的交易建议或者直接通过受管理的期货账户参与实际交易来获得收益的机构或个人。传统意义上的CTA 基金的投资品种仅限于商品期货，但随着近年来全球期货市场的发展，CTA 基金逐渐将其投资领域扩展到包括利率期货、股指期货、外汇期货在内的几乎所有期货品种。CTA与其他资产或者策略种类的相关性较低，所以一直在资产配置或交易策略中占据重要的一席之地。\nCTA分类\n日间低频趋势策略\n均线突破策略 布林通道策略 海龟交易法则 Aberration策略 日内高频趋势策略\nR-breaker Dual-thrust ART定破 形态识别，机器学习等 套利策略\n期现套利 跨期套利 跨品种套利 跨市场套利 参考：https://www.gfedu.cn/aqf/content_23580.shtml\n","permalink":"https://aixin.me/post/quantitative-trading-learning/","summary":"一、凯利公式 英文：The Kelly Criterion\n在概率论中，凯利公式（也称 “凯利方程式”）是一个在期望净收益为正的独立重复赌局中，使本金的长期增长率最大化的投注策略。该公式于 1956 年由约翰·拉里·凯利（John Larry Kelly）在《贝尔系统技术期刊》中发表，可以用来计算每次游戏中应投注的资金比例。若赌局的期望净收益为零或为负，凯利公式给出的结论是不赌为赢。\n公式： $$ f^* = \\frac {bp-q}{b} = \\frac {p(b+1)-1}{b} $$\n$f^*$ = 应投注的资本比值 p = 获胜的概率 q = 失败的概率 b = 赔率\n例子：有一个简单2赔1的赌局，扔硬币下注，硬币为正面则得2元，如果为反面则输掉1元，你的总资产为100元，每一次的押注都可投入任意金额。你会怎么赌呢？\n硬币抛出正反面的概率都是50%，所以p、q获胜失败的概率都为0.5，而赔率＝期望盈利÷可能亏损=2元盈利÷1元亏损，赔率就是2，我们要求的答案是f，也就是(bp - q) ÷ b = (2 * 50% - 50%) ÷ 2 = 25%。拿出资金的25%来进行下注，才能使赌局收益最大化。\n真正应该关心的是长期累积的收入，对于累积的收益来说，最后的结果只和输赢的局数有关，而和输赢的顺序无关。所以凯利公式推出了一个最佳的投入仓位比，来最大化长期的累积收益： $$ bet = edge / odds $$\n最佳仓位bet = 预期获益 / 获益回报 edge：赢面 odds：赔率\n$$ edge = bp - q $$","title":"量化交易相关名词解释"},{"content":"官方教程 https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/\n1、Spring Boot介绍 Spring Boot可以轻松创建可以运行的独立的，生产级的基于Spring的应用程序。我们对Spring平台和第三方库采取自己的看法，以便您尽可能轻松地使用本教程。大多数Spring Boot应用程序只需要很少的Spring配置。\n您可以使用Spring Boot来创建可以使用java -jar或更传统的war部署来启动的Java应用程序 。我们还提供了一个运行“spring script”的命令行工具。\n2、系统要求 Spring Boot 2.2.1需要Java 8 及以上版本，同时也兼容了Java 13\n支持以下构建程序：\nMaven 版本3.3+ Gradle 5.x Servlet容器：\nName Servlet版本 Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 3、Spring Boot安装 服务器SDK最低要求为：Java SDK v1.8 查看环境Java版本：java -version\n安装方法一 您可以像使用任何标准Java库一样使用Spring Boot。为此，请spring-boot-*.jar在类路径中包含相应的文件。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。此外，Spring Boot应用程序没有什么特别之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。\n虽然您可以复制Spring Boot jar，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。\n安装方法二、使用Maven安装（推荐） Maven版本最低要求3.3+，前提是先要安装Maven（https://maven.apache.org/）。 或者通过IDE安装Maven插件 Spring Boot依赖关系使用org.springframework.bootgroupId。通常，您的Maven POM文件从spring-boot-starter-parent项目中继承并向一个或多个“Starter”声明依赖关系。Spring Boot还提供了一个可选的 Maven插件来创建可执行的jar。 以下清单显示了一个典型的pom.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;myproject\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;!-- Inherit defaults from Spring Boot --\u0026gt;\r\u0026lt;parent\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt;\r\u0026lt;/parent\u0026gt;\r\u0026lt;!-- Override inherited settings --\u0026gt;\r\u0026lt;description/\u0026gt;\r\u0026lt;developers\u0026gt;\r\u0026lt;developer/\u0026gt;\r\u0026lt;/developers\u0026gt;\r\u0026lt;licenses\u0026gt;\r\u0026lt;license/\u0026gt;\r\u0026lt;/licenses\u0026gt;\r\u0026lt;scm\u0026gt;\r\u0026lt;url/\u0026gt;\r\u0026lt;/scm\u0026gt;\r\u0026lt;url/\u0026gt;\r\u0026lt;!-- 添加依赖关系--\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;!-- 引入将应用打包成可执行的jar包的插件 --\u0026gt;\r\u0026lt;build\u0026gt;\r\u0026lt;plugins\u0026gt;\r\u0026lt;plugin\u0026gt;\r\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;\r\u0026lt;/plugin\u0026gt;\r\u0026lt;/plugins\u0026gt;\r\u0026lt;/build\u0026gt;\r\u0026lt;/project\u0026gt; spring-boot-starter-parent方法虽然很好，但不是适合所有场景。\n4、开发第一个Spring Boot应用 ","permalink":"https://aixin.me/post/spring-boot-getting-started/","summary":"官方教程 https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/\n1、Spring Boot介绍 Spring Boot可以轻松创建可以运行的独立的，生产级的基于Spring的应用程序。我们对Spring平台和第三方库采取自己的看法，以便您尽可能轻松地使用本教程。大多数Spring Boot应用程序只需要很少的Spring配置。\n您可以使用Spring Boot来创建可以使用java -jar或更传统的war部署来启动的Java应用程序 。我们还提供了一个运行“spring script”的命令行工具。\n2、系统要求 Spring Boot 2.2.1需要Java 8 及以上版本，同时也兼容了Java 13\n支持以下构建程序：\nMaven 版本3.3+ Gradle 5.x Servlet容器：\nName Servlet版本 Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 3、Spring Boot安装 服务器SDK最低要求为：Java SDK v1.8 查看环境Java版本：java -version\n安装方法一 您可以像使用任何标准Java库一样使用Spring Boot。为此，请spring-boot-*.jar在类路径中包含相应的文件。Spring Boot不需要任何特殊的工具集成，因此您可以使用任何IDE或文本编辑器。此外，Spring Boot应用程序没有什么特别之处，因此您可以像运行其他任何Java程序一样运行和调试Spring Boot应用程序。\n虽然您可以复制Spring Boot jar，但我们通常建议您使用支持依赖管理的构建工具（如Maven或Gradle）。\n安装方法二、使用Maven安装（推荐） Maven版本最低要求3.3+，前提是先要安装Maven（https://maven.apache.org/）。 或者通过IDE安装Maven插件 Spring Boot依赖关系使用org.springframework.bootgroupId。通常，您的Maven POM文件从spring-boot-starter-parent项目中继承并向一个或多个“Starter”声明依赖关系。Spring Boot还提供了一个可选的 Maven插件来创建可执行的jar。 以下清单显示了一个典型的pom.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.","title":"Spring Boot 入门指南"},{"content":"生成数组\nnumpy.arange([start, ]stop, [step, ]dtype=None)\n示例\nnp.arange(3) array([0, 1, 2]) np.arange(3.0) array([ 0., 1., 2.]) np.arange(3,7) array([3, 4, 5, 6]) np.arange(3,7,2) array([3, 5]) 生成随机整数\nnumpy.random.randint(low, high=None, size=None, dtype=\u0026lsquo;l\u0026rsquo;)\n示例\nnp.random.randint(2, size=10) array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) np.random.randint(1, size=10) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 随机排列\nnp.random.shuffle(x)\n示例\narr = np.arange(10) np.random.shuffle(arr) arr [1 7 5 2 9 4 3 6 0 8] 随机采样\nnumpy.random.choice(a, size=None, replace=True, p=None)\n示例\nnp.random.choice(5, 3) array([0, 3, 4]) #This is equivalent to np.random.randint(0,5,3) ","permalink":"https://aixin.me/post/numpy/","summary":"生成数组\nnumpy.arange([start, ]stop, [step, ]dtype=None)\n示例\nnp.arange(3) array([0, 1, 2]) np.arange(3.0) array([ 0., 1., 2.]) np.arange(3,7) array([3, 4, 5, 6]) np.arange(3,7,2) array([3, 5]) 生成随机整数\nnumpy.random.randint(low, high=None, size=None, dtype=\u0026lsquo;l\u0026rsquo;)\n示例\nnp.random.randint(2, size=10) array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) np.random.randint(1, size=10) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 随机排列\nnp.random.shuffle(x)\n示例\narr = np.arange(10) np.random.shuffle(arr) arr [1 7 5 2 9 4 3 6 0 8] 随机采样","title":"Numpy学习笔记"}]