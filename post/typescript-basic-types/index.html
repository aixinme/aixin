<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Typescript Basic Types | 爱心网-Aixin.me</title>
<meta name=keywords content="TypeScript">
<meta name=description content="基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。
Boolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。
let isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。
let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（&#34;）或单引号（'）表示字符串。
let name: string = &#34;bob&#34;; name = &#34;smith&#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式
let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }.">
<meta name=author content="Aixin.me">
<link rel=canonical href=https://aixin.me/post/typescript-basic-types/>
<link href=/assets/css/stylesheet.min.65503748e9ebcf60fe22865c7e7727c1cf70e446031c37ef428743ad2310156a.css integrity="sha256-ZVA3SOnrz2D+IoZcfncnwc9w5EYDHDfvQodDrSMQFWo=" rel="preload stylesheet" as=style>
<link rel=icon href=https://aixin.me/images/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://aixin.me/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://aixin.me/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://aixin.me/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://aixin.me/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.2">
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<meta property="og:title" content="Typescript Basic Types">
<meta property="og:description" content="基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。
Boolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。
let isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。
let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（&#34;）或单引号（'）表示字符串。
let name: string = &#34;bob&#34;; name = &#34;smith&#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式
let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://aixin.me/post/typescript-basic-types/"><meta property="og:image" content="https://aixin.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-08-24T20:20:32+08:00">
<meta property="article:modified_time" content="2021-08-24T20:20:32+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://aixin.me/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Typescript Basic Types">
<meta name=twitter:description content="基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。
Boolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。
let isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。
let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（&#34;）或单引号（'）表示字符串。
let name: string = &#34;bob&#34;; name = &#34;smith&#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式
let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://aixin.me/post/"},{"@type":"ListItem","position":3,"name":"Typescript Basic Types","item":"https://aixin.me/post/typescript-basic-types/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Typescript Basic Types","name":"Typescript Basic Types","description":"基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\nBoolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\nlet isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\nlet decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（\u0026quot;）或单引号（'）表示字符串。\nlet name: string = \u0026#34;bob\u0026#34;; name = \u0026#34;smith\u0026#34;; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式\nlet name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }.","keywords":["TypeScript"],"articleBody":"基础类型 介绍 为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\nBoolean 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\nlet isDone: boolean = false; Number 和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是number， 而大整数的类型则是 bigint。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\nlet decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; let bigLiteral: bigint = 100n; String JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用string表示文本数据类型。 和JavaScript一样，可以使用双引号（\"）或单引号（'）表示字符串。\nlet name: string = \"bob\"; name = \"smith\"; 你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以${ expr }这种形式嵌入表达式\nlet name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I'll be ${ age + 1 }years old next month.`; 这与下面定义sentence的方式效果相同：\nlet sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" + \"I'll be \" + (age + 1) + \" years old next month.\"; Array TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：\nlet list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array：\nlet list: Arraynumber = [1, 2, 3]; Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元组。\n// Declare a tuple type let x: [string, number]; // Initialize it x = ['hello', 10]; // OK // Initialize it incorrectly x = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型：\nconsole.log(x[0].substr(1)); // OK console.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素会报错。\nx[3] = \"world\"; // Error, Property '3' does not exist on type '[string, number]'.  console.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'. Enum enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color {Red, Green, Blue} let c: Color = Color.Green; 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从1开始编号：\nenum Color {Red = 1, Green, Blue} let c: Color = Color.Green; 或者，全部都采用手动赋值：\nenum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\nenum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; console.log(colorName); // 显示'Green'因为上面代码里它的值是2 Unknown 当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 unknown 类型。\nlet notSure: unknown = 4; notSure = \"maybe a string instead\"; // OK, definitely a boolean notSure = false; 如果你有一个 unknwon 类型的变量，你可以通过进行 typeof 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：\n// @errors: 2322 2322 2322 declare const maybe: unknown; // 'maybe' could be a string, object, boolean, undefined, or other types const aNumber: number = maybe; if (maybe === true) { // TypeScript knows that maybe is a boolean now  const aBoolean: boolean = maybe; // So, it cannot be a string  const aString: string = maybe; } if (typeof maybe === \"string\") { // TypeScript knows that maybe is a string  const aString: string = maybe; // So, it cannot be a boolean  const aBoolean: boolean = maybe; } Any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量：\nlet notSure: any = 4; notSure = \"maybe a string instead\"; notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\nlet notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)  let prettySure: Object = 4; prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.  注意：应避免使用Object，而是使用非原始object类型，正如Do’s and Don’ts里所讲的那样。\n 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\nlet list: any[] = [1, true, \"free\"]; list[1] = 100; Void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void：\nfunction warnUser(): void { console.log(\"This is my warning message\"); } 声明一个void类型的变量没有什么大用，因为你只能为它赋予null（只在--strictNullChecks未指定时）和undefined：\nlet unusable: void = undefined; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和void相似，它们的本身的类型用处不是很大：\n// Not much else we can assign to these variables! let u: undefined = undefined; let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。\n然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给any和它们各自的类型（有一个例外是undefined还可以赋值给void类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。\n联合类型是高级主题，我们会在以后的章节里讨论它。\n 注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。\n Never never类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。\n下面是一些返回never类型的函数：\n// 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object object表示非原始类型，也就是除number，string，boolean，bigint，symbol，null或undefined之外的类型。\n使用object类型，就可以更好的表示像Object.create这样的API。例如：\ndeclare function create(o: object | null): void; create({ prop: 0 }); // OK create(null); // OK  create(42); // Error create(\"string\"); // Error create(false); // Error create(undefined); // Error 类型断言 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n类型断言有两种形式。 其一是“尖括号”语法：\nlet someValue: any = \"this is a string\"; let strLength: number = (stringsomeValue).length; 另一个为as语法：\nlet someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。\n关于let 你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let是ES2015引入的关键字，它比var更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用let来解决，所以尽可能地使用let来代替var吧。\n关于 Number, String, Boolean, Symbol 和 Object 我们很容易会认为 Number、 String、 Boolean、Symbol 以及 Object 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：\n// @errors: 2339 function reverse(s: String): String { return s.split(\"\").reverse().join(\"\"); } reverse(\"hello world\"); 相对地，我们应该使用 number、string、boolean、object 和 symbol\nfunction reverse(s: string): string { return s.split(\"\").reverse().join(\"\"); } reverse(\"hello world\"); ","wordCount":"681","inLanguage":"zh","datePublished":"2021-08-24T20:20:32+08:00","dateModified":"2021-08-24T20:20:32+08:00","author":{"@type":"Person","name":"Aixin.me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aixin.me/post/typescript-basic-types/"},"publisher":{"@type":"Organization","name":"爱心网-Aixin.me","logo":{"@type":"ImageObject","url":"https://aixin.me/images/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://aixin.me accesskey=h title="Aixin.me (Alt + H)">Aixin.me</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://aixin.me/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://aixin.me/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://aixin.me/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://aixin.me/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Typescript Basic Types
</h1>
<div class=post-meta>
August 24, 2021&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;Aixin.me
</div>
</header>
<div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>目录</div>
</summary>
<div class=inner><ul><li>
<a href=#%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b aria-label=基础类型>基础类型</a><ul>
<li>
<a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li>
<a href=#boolean aria-label=Boolean>Boolean</a></li><li>
<a href=#number aria-label=Number>Number</a></li><li>
<a href=#string aria-label=String>String</a></li><li>
<a href=#array aria-label=Array>Array</a></li><li>
<a href=#tuple aria-label=Tuple>Tuple</a></li><li>
<a href=#enum aria-label=Enum>Enum</a></li><li>
<a href=#unknown aria-label=Unknown>Unknown</a></li><li>
<a href=#any aria-label=Any>Any</a></li><li>
<a href=#void aria-label=Void>Void</a></li><li>
<a href=#null-%e5%92%8c-undefined aria-label="Null 和 Undefined">Null 和 Undefined</a></li><li>
<a href=#never aria-label=Never>Never</a></li><li>
<a href=#object aria-label=Object>Object</a></li><li>
<a href=#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label=类型断言>类型断言</a></li><li>
<a href=#%e5%85%b3%e4%ba%8elet aria-label=关于let>关于<code>let</code></a></li><li>
<a href=#%e5%85%b3%e4%ba%8e-number-string-boolean-symbol-%e5%92%8c-object aria-label="关于 Number, String, Boolean, Symbol 和 Object">关于 Number, String, Boolean, Symbol 和 Object</a></li></ul>
</li></ul>
</div>
</details>
</div>
<div class=post-content>
<h3 id=基础类型>基础类型<a hidden class=anchor aria-hidden=true href=#基础类型>#</a></h3>
<h4 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h4>
<p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h4 id=boolean>Boolean<a hidden class=anchor aria-hidden=true href=#boolean>#</a></h4>
<p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>isDone</span>: <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</code></pre></div><h4 id=number>Number<a hidden class=anchor aria-hidden=true href=#number>#</a></h4>
<p>和JavaScript一样，TypeScript里的所有数字都是浮点数或者大整数 。 这些浮点数的类型是<code>number</code>， 而大整数的类型则是 <code>bigint</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>decLiteral</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>hexLiteral</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xf00d</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>binaryLiteral</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#a6e22e>b1010</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>octalLiteral</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#a6e22e>o744</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bigLiteral</span>: <span style=color:#66d9ef>bigint</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span><span style=color:#a6e22e>n</span>;
</code></pre></div><h4 id=string>String<a hidden class=anchor aria-hidden=true href=#string>#</a></h4>
<p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用<code>string</code>表示文本数据类型。 和JavaScript一样，可以使用双引号（<code>"</code>）或单引号（<code>'</code>）表示字符串。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bob&#34;</span>;
<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;smith&#34;</span>;
</code></pre></div><p>你还可以使用_模版字符串_，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（` `），并且以<code>${ expr }</code>这种形式嵌入表达式</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`Gene`</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>age</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>sentence</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`Hello, my name is </span><span style=color:#e6db74>${</span> <span style=color:#a6e22e>name</span> <span style=color:#e6db74>}</span><span style=color:#e6db74>.
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>I&#39;ll be </span><span style=color:#e6db74>${</span> <span style=color:#a6e22e>age</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>}</span><span style=color:#e6db74> years old next month.`</span>;
</code></pre></div><p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>sentence</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, my name is &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.\n\n&#34;</span> <span style=color:#f92672>+</span>
    <span style=color:#e6db74>&#34;I&#39;ll be &#34;</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>age</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; years old next month.&#34;</span>;
</code></pre></div><h4 id=array>Array<a hidden class=anchor aria-hidden=true href=#array>#</a></h4>
<p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>list</span>: <span style=color:#66d9ef>number</span>[] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</code></pre></div><p>第二种方式是使用数组泛型，<code>Array&lt;元素类型></code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>list</span>: <span style=color:#66d9ef>Array</span>&lt;<span style=color:#f92672>number</span>&gt; <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</code></pre></div><h4 id=tuple>Tuple<a hidden class=anchor aria-hidden=true href=#tuple>#</a></h4>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// Declare a tuple type
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> [<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>number</span>];
<span style=color:#75715e>// Initialize it
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;hello&#39;</span>, <span style=color:#ae81ff>10</span>]; <span style=color:#75715e>// OK
</span><span style=color:#75715e>// Initialize it incorrectly
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#39;hello&#39;</span>]; <span style=color:#75715e>// Error
</span></code></pre></div><p>当访问一个已知索引的元素，会得到正确的类型：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>substr</span>(<span style=color:#ae81ff>1</span>)); <span style=color:#75715e>// OK
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>substr</span>(<span style=color:#ae81ff>1</span>)); <span style=color:#75715e>// Error, &#39;number&#39; does not have &#39;substr&#39;
</span></code></pre></div><p>当访问一个越界的元素会报错。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;world&#34;</span>; <span style=color:#75715e>// Error, Property &#39;3&#39; does not exist on type &#39;[string, number]&#39;.
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>x</span>[<span style=color:#ae81ff>5</span>].<span style=color:#a6e22e>toString</span>()); <span style=color:#75715e>// Error, Property &#39;5&#39; does not exist on type &#39;[string, number]&#39;.
</span></code></pre></div><h4 id=enum>Enum<a hidden class=anchor aria-hidden=true href=#enum>#</a></h4>
<p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {<span style=color:#a6e22e>Red</span>, <span style=color:#a6e22e>Green</span>, <span style=color:#a6e22e>Blue</span>}
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>c</span>: <span style=color:#66d9ef>Color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>.<span style=color:#a6e22e>Green</span>;
</code></pre></div><p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {<span style=color:#a6e22e>Red</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Green</span>, <span style=color:#a6e22e>Blue</span>}
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>c</span>: <span style=color:#66d9ef>Color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>.<span style=color:#a6e22e>Green</span>;
</code></pre></div><p>或者，全部都采用手动赋值：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {<span style=color:#a6e22e>Red</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Green</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>Blue</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>}
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>c</span>: <span style=color:#66d9ef>Color</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>.<span style=color:#a6e22e>Green</span>;
</code></pre></div><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {<span style=color:#a6e22e>Red</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Green</span>, <span style=color:#a6e22e>Blue</span>}
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colorName</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>[<span style=color:#ae81ff>2</span>];

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>colorName</span>);  <span style=color:#75715e>// 显示&#39;Green&#39;因为上面代码里它的值是2
</span></code></pre></div><h4 id=unknown>Unknown<a hidden class=anchor aria-hidden=true href=#unknown>#</a></h4>
<p>当我们在写应用的时候可能会需要描述一个我们还不知道其类型的变量。这些值可以来自动态内容，例如从用户获得，或者我们想在我们的 API 中接收所有可能类型的值。在这些情况下，我们想要让编译器以及未来的用户知道这个变量可以是任意类型。这个时候我们会对它使用 <code>unknown</code> 类型。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>notSure</span>: <span style=color:#66d9ef>unknown</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
<span style=color:#a6e22e>notSure</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maybe a string instead&#34;</span>;

<span style=color:#75715e>// OK, definitely a boolean
</span><span style=color:#75715e></span><span style=color:#a6e22e>notSure</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</code></pre></div><p>如果你有一个 <code>unknwon</code> 类型的变量，你可以通过进行 <code>typeof</code> 、比较或者更高级的类型检查来将其的类型范围缩小，这些方法会在后续章节中进一步讨论：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// @errors: 2322 2322 2322
</span><span style=color:#75715e></span><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maybe</span>: <span style=color:#66d9ef>unknown</span>;
<span style=color:#75715e>// &#39;maybe&#39; could be a string, object, boolean, undefined, or other types
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aNumber</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maybe</span>;

<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>maybe</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>true</span>) {
  <span style=color:#75715e>// TypeScript knows that maybe is a boolean now
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aBoolean</span>: <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maybe</span>;
  <span style=color:#75715e>// So, it cannot be a string
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aString</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maybe</span>;
}

<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>maybe</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;string&#34;</span>) {
  <span style=color:#75715e>// TypeScript knows that maybe is a string
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aString</span>: <span style=color:#66d9ef>string</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maybe</span>;
  <span style=color:#75715e>// So, it cannot be a boolean
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aBoolean</span>: <span style=color:#66d9ef>boolean</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>maybe</span>;
}
</code></pre></div><h4 id=any>Any<a hidden class=anchor aria-hidden=true href=#any>#</a></h4>
<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用<code>any</code>类型来标记这些变量：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>notSure</span>: <span style=color:#66d9ef>any</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
<span style=color:#a6e22e>notSure</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maybe a string instead&#34;</span>;
<span style=color:#a6e22e>notSure</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// okay, definitely a boolean
</span></code></pre></div><p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>notSure</span>: <span style=color:#66d9ef>any</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
<span style=color:#a6e22e>notSure</span>.<span style=color:#a6e22e>ifItExists</span>(); <span style=color:#75715e>// okay, ifItExists might exist at runtime
</span><span style=color:#75715e></span><span style=color:#a6e22e>notSure</span>.<span style=color:#a6e22e>toFixed</span>(); <span style=color:#75715e>// okay, toFixed exists (but the compiler doesn&#39;t check)
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>prettySure</span>: <span style=color:#66d9ef>Object</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
<span style=color:#a6e22e>prettySure</span>.<span style=color:#a6e22e>toFixed</span>(); <span style=color:#75715e>// Error: Property &#39;toFixed&#39; doesn&#39;t exist on type &#39;Object&#39;.
</span></code></pre></div><blockquote>
<p>注意：应避免使用<code>Object</code>，而是使用非原始<code>object</code>类型，正如<a href="../doc/handbook/declaration%20files/Do's%20and%20Don'ts.md">Do&rsquo;s and Don&rsquo;ts</a>里所讲的那样。</p>
</blockquote>
<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>list</span>: <span style=color:#66d9ef>any</span>[] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>true</span>, <span style=color:#e6db74>&#34;free&#34;</span>];

<span style=color:#a6e22e>list</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</code></pre></div><h4 id=void>Void<a hidden class=anchor aria-hidden=true href=#void>#</a></h4>
<p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>warnUser</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;This is my warning message&#34;</span>);
}
</code></pre></div><p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>null</code>（只在<code>--strictNullChecks</code>未指定时）和<code>undefined</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>unusable</span>: <span style=color:#66d9ef>void</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</code></pre></div><h4 id=null-和-undefined>Null 和 Undefined<a hidden class=anchor aria-hidden=true href=#null-和-undefined>#</a></h4>
<p>TypeScript里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和<code>void</code>相似，它们的本身的类型用处不是很大：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// Not much else we can assign to these variables!
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>u</span>: <span style=color:#66d9ef>undefined</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>n</span>: <span style=color:#66d9ef>null</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</code></pre></div><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>any</code>和它们各自的类型（有一个例外是<code>undefined</code>还可以赋值给<code>void</code>类型）。 这能避免_很多_常见的问题。 也许在某处你想传入一个<code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。</p>
<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<blockquote>
<p>注意：我们鼓励尽可能地使用<code>--strictNullChecks</code>，但在本手册里我们假设这个标记是关闭的。</p>
</blockquote>
<h4 id=never>Never<a hidden class=anchor aria-hidden=true href=#never>#</a></h4>
<p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，_没有_类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// 返回never的函数必须存在无法达到的终点
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span> {
    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#a6e22e>message</span>);
}

<span style=color:#75715e>// 推断的返回值类型为never
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fail() {</span>
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;Something failed&#34;</span>);
}

<span style=color:#75715e>// 返回never的函数必须存在无法达到的终点
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>infiniteLoop</span>()<span style=color:#f92672>:</span> <span style=color:#66d9ef>never</span> {
    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
    }
}
</code></pre></div><h4 id=object>Object<a hidden class=anchor aria-hidden=true href=#object>#</a></h4>
<p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>bigint</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>declare</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>o</span>: <span style=color:#66d9ef>object</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>null</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span>;

<span style=color:#a6e22e>create</span>({ <span style=color:#a6e22e>prop</span>: <span style=color:#66d9ef>0</span> }); <span style=color:#75715e>// OK
</span><span style=color:#75715e></span><span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>null</span>); <span style=color:#75715e>// OK
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>create</span>(<span style=color:#ae81ff>42</span>); <span style=color:#75715e>// Error
</span><span style=color:#75715e></span><span style=color:#a6e22e>create</span>(<span style=color:#e6db74>&#34;string&#34;</span>); <span style=color:#75715e>// Error
</span><span style=color:#75715e></span><span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>false</span>); <span style=color:#75715e>// Error
</span><span style=color:#75715e></span><span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>undefined</span>); <span style=color:#75715e>// Error
</span></code></pre></div><h4 id=类型断言>类型断言<a hidden class=anchor aria-hidden=true href=#类型断言>#</a></h4>
<p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过_类型断言_这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>someValue</span>: <span style=color:#66d9ef>any</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is a string&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>strLength</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> (&lt;<span style=color:#f92672>string</span>&gt;<span style=color:#a6e22e>someValue</span>).<span style=color:#a6e22e>length</span>;
</code></pre></div><p>另一个为<code>as</code>语法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>someValue</span>: <span style=color:#66d9ef>any</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;this is a string&#34;</span>;

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>strLength</span>: <span style=color:#66d9ef>number</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>someValue</span> <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>string</span>).<span style=color:#a6e22e>length</span>;
</code></pre></div><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有<code>as</code>语法断言是被允许的。</p>
<h4 id=关于let>关于<code>let</code><a hidden class=anchor aria-hidden=true href=#关于let>#</a></h4>
<p>你可能已经注意到了，我们使用<code>let</code>关键字来代替大家所熟悉的JavaScript关键字<code>var</code>。 <code>let</code>是ES2015引入的关键字，它比<code>var</code>更加安全，因此被看做是声明变量的标准方式。 我们会在以后详细介绍它，很多常见的问题都可以通过使用<code>let</code>来解决，所以尽可能地使用<code>let</code>来代替<code>var</code>吧。</p>
<h4 id=关于-number-string-boolean-symbol-和-object>关于 Number, String, Boolean, Symbol 和 Object<a hidden class=anchor aria-hidden=true href=#关于-number-string-boolean-symbol-和-object>#</a></h4>
<p>我们很容易会认为 <code>Number</code>、 <code>String</code>、 <code>Boolean</code>、<code>Symbol</code> 以及 <code>Object</code> 这些类型和我们以上推荐的小写版本的类型是一样的。但这些类型不属于语言的基本类型，并且几乎在任何时候都不应该被用作一个类型：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#75715e>// @errors: 2339
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span>: <span style=color:#66d9ef>String</span>)<span style=color:#f92672>:</span> String {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>);
}

<span style=color:#a6e22e>reverse</span>(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</code></pre></div><p>相对地，我们应该使用 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>object</code> 和 <code>symbol</code></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>reverse</span>(<span style=color:#a6e22e>s</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34;&#34;</span>);
}

<span style=color:#a6e22e>reverse</span>(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://aixin.me/tags/typescript/>TypeScript</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>❤️ &copy; 2021 <a href=https://aixin.me>爱心网-Aixin.me</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?4ebd66106c8ed3e1fc88a9e64ee33fb8",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>